/* -LICENSE-START-
** Copyright (c) 2019 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
// SinkWriter.cpp : implementation file
// Media Sink Writer
//

#include "stdafx.h"
#include <map>
#include <thread>
#include "mfapi.h"
#include "mfidl.h"
#include "mferror.h"
#include "SinkWriter.h"

static const UINT32 kVideoEncodedBitRate = 20 * 1000 * 1000;
static const UINT32 kAudioEncodedBitRate = 192000;

static const std::map<BMDPixelFormat, GUID> kPixelFormatMap = {
	{bmdFormat8BitYUV, MFVideoFormat_UYVY},
	{bmdFormat8BitBGRA, MFVideoFormat_RGB32}
};

static const std::map<BMDFieldDominance, MFVideoInterlaceMode> kFieldDominanceMap = {
	{ bmdUnknownFieldDominance, MFVideoInterlace_Unknown },
	{ bmdLowerFieldFirst, MFVideoInterlace_FieldInterleavedLowerFirst },
	{ bmdUpperFieldFirst, MFVideoInterlace_FieldInterleavedUpperFirst },
	{ bmdProgressiveFrame, MFVideoInterlace_Progressive},
};

SinkWriter::SinkWriter() :
	m_refCount(1),
	m_sinkWriter(nullptr),
	m_videoStreamIndex(0),
	m_audioStreamIndex(0)
{
}

// IUnknown methods

HRESULT SinkWriter::QueryInterface(REFIID iid, LPVOID* ppv)
{
	*ppv = nullptr;
	return E_NOTIMPL;
}

ULONG SinkWriter::AddRef(void)
{
	return ++m_refCount;
}

ULONG SinkWriter::Release(void)
{
	ULONG newRefValue = --m_refCount;

	if (newRefValue == 0)
		delete this;

	return newRefValue;
}

// Other methods

HRESULT SinkWriter::Initialize(CComPtr<IDeckLinkDisplayMode> inputDisplayMode, BMDPixelFormat inputPixelFormat, BMDAudioSampleType bitsPerSample, uint32_t channelCount, CString outputFilename)
{
	HRESULT hr = E_FAIL;

	if (m_sinkWriter)
		// Already initialized, bail
		goto bail;

	hr = MFCreateSinkWriterFromURL(CT2CW(outputFilename), NULL, NULL, &m_sinkWriter);
	if (hr != S_OK)
		goto bail;

	// Configure video encoder media type
	hr = ConfigureVideoEncoder(inputDisplayMode, inputPixelFormat);
	if (hr != S_OK)
		goto bail;

	// Configure audio encoder media type
	hr = ConfigureAudioEncoder(bitsPerSample, channelCount);
	if (hr != S_OK)
		goto bail;

	// Tell the sink writer to start accepting data.
	hr = m_sinkWriter->BeginWriting();

bail:
	return hr;
}

void SinkWriter::SinkWriterThread(CComPtr<SampleMemoryAllocator> videoQueue, CComPtr<AudioSampleQueue> audioQueue)
{
	// Start threads for video and audio capture
	std::thread videoWriterThread(&SinkWriter::VideoSinkWriterThread, this, videoQueue);
	std::thread audioWriterThread(&SinkWriter::AudioSinkWriterThread, this, audioQueue);

	// Wait for threads to complete
	videoWriterThread.join();
	audioWriterThread.join();

	// Finalize write
	std::lock_guard<std::mutex> lock(m_sinkWriterMutex);
	m_sinkWriter->Finalize();

	// Release sink writer so can be re-initialized
	m_sinkWriter.Release();
}

void SinkWriter::VideoSinkWriterThread(CComPtr<SampleMemoryAllocator> videoQueue)
{
	bool captureRunning = true;

	while (captureRunning)
	{
		bool					captureCancelled;
		CComPtr<IMFSample>		sample;

		if (!videoQueue->WaitForInputSample(&sample, captureCancelled) || captureCancelled)
		{
			captureRunning = false;
		}
		else
		{
			std::lock_guard<std::mutex> lock(m_sinkWriterMutex);
			if (m_sinkWriter->WriteSample(m_videoStreamIndex, sample) != S_OK)
				captureRunning = false;
		}
	}
}

void SinkWriter::AudioSinkWriterThread(CComPtr<AudioSampleQueue> audioQueue)
{
	bool captureRunning = true;

	while (captureRunning)
	{
		bool					captureCancelled;
		CComPtr<IMFSample>		sample;
		
		if (!audioQueue->WaitForInputSample(&sample, captureCancelled) || captureCancelled)
		{
			captureRunning = false;
		}
		else
		{
			std::lock_guard<std::mutex> lock(m_sinkWriterMutex);
			if (m_sinkWriter->WriteSample(m_audioStreamIndex, sample) != S_OK)
				captureRunning = false;
		}
	}
}

HRESULT SinkWriter::ConfigureVideoEncoder(CComPtr<IDeckLinkDisplayMode> inputDisplayMode, BMDPixelFormat inputPixelFormat)
{
	HRESULT					hr				= E_FAIL;	
	CComPtr<IMFMediaType>	mediaTypeOut	= nullptr;
	CComPtr<IMFMediaType>   mediaTypeIn		= nullptr;
	BMDTimeScale			frameTimescale	= 0;
	BMDTimeValue			frameDuration	= 0;

	// Try to map the BMDPixelFormat to MF_MT_SUBTYPE GUID
	auto formatIter = kPixelFormatMap.find(inputPixelFormat);
	if (formatIter == kPixelFormatMap.end())
		// Could not match pixel format
		return E_FAIL;

	auto fieldDominanceIter = kFieldDominanceMap.find(inputDisplayMode->GetFieldDominance());
	if (fieldDominanceIter == kFieldDominanceMap.end())
		// Could not match field dominance (incoming signal PsF?)
		return E_FAIL;

	hr = inputDisplayMode->GetFrameRate(&frameDuration, &frameTimescale);
	if (hr != S_OK)
		goto bail;

	// Set the output video media type.
	hr = MFCreateMediaType(&mediaTypeOut);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeOut->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeOut->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_H264);
	if (hr != S_OK)
		goto bail;
	
	hr = mediaTypeOut->SetUINT32(MF_MT_AVG_BITRATE, kVideoEncodedBitRate);
	if (hr != S_OK)
		goto bail;
	
	hr = mediaTypeOut->SetUINT32(MF_MT_INTERLACE_MODE, MFVideoInterlace_Progressive); 
	if (hr != S_OK)
		goto bail;
	
	hr = MFSetAttributeSize(mediaTypeOut, MF_MT_FRAME_SIZE, inputDisplayMode->GetWidth(), inputDisplayMode->GetHeight());
	if (hr != S_OK)
		goto bail;
	
	hr = MFSetAttributeRatio(mediaTypeOut, MF_MT_FRAME_RATE, (UINT32)frameTimescale, (UINT32)frameDuration);
	if (hr != S_OK)
		goto bail;
	
	hr = MFSetAttributeRatio(mediaTypeOut, MF_MT_PIXEL_ASPECT_RATIO, 1, 1);
	if (hr != S_OK)
		goto bail;
	
	hr = m_sinkWriter->AddStream(mediaTypeOut, &m_videoStreamIndex);
	if (hr != S_OK)
		goto bail;

	// Set the input media type.
	hr = MFCreateMediaType(&mediaTypeIn);
	if (hr != S_OK)
		goto bail;
	
	hr = mediaTypeIn->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);
	if (hr != S_OK)
		goto bail;
	
	hr = mediaTypeIn->SetGUID(MF_MT_SUBTYPE, formatIter->second);
	if (hr != S_OK)
		goto bail;
	
	hr = mediaTypeIn->SetUINT32(MF_MT_INTERLACE_MODE, fieldDominanceIter->second);
	if (hr != S_OK)
		goto bail;
	
	hr = MFSetAttributeSize(mediaTypeIn, MF_MT_FRAME_SIZE, inputDisplayMode->GetWidth(), inputDisplayMode->GetHeight());
	if (hr != S_OK)
		goto bail;
	
	hr = MFSetAttributeRatio(mediaTypeIn, MF_MT_FRAME_RATE, (UINT32)frameTimescale, (UINT32)frameDuration);
	if (hr != S_OK)
		goto bail;
	
	hr = MFSetAttributeRatio(mediaTypeIn, MF_MT_PIXEL_ASPECT_RATIO, 1, 1);
	if (hr != S_OK)
		goto bail;
	
	hr = m_sinkWriter->SetInputMediaType(m_videoStreamIndex, mediaTypeIn, NULL);

bail:
	return hr;
}

HRESULT SinkWriter::ConfigureAudioEncoder(BMDAudioSampleType bitsPerSample, uint32_t channelCount)
{
	HRESULT					hr				= S_OK;
	CComPtr<IMFMediaType>	mediaTypeOut	= nullptr;
	CComPtr<IMFMediaType>   mediaTypeIn		= nullptr;

	// Calculate derived values.
	uint32_t blockAlign = channelCount * (bitsPerSample / 8);
	uint32_t bytesPerSecond = blockAlign * bmdAudioSampleRate48kHz;

	// Set the output audio media type.
	hr = MFCreateMediaType(&mediaTypeOut);
	if (hr != S_OK)
		goto bail;

	// Set attributes on the type.
	hr = mediaTypeOut->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeOut->SetGUID(MF_MT_SUBTYPE, MFAudioFormat_AAC);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeOut->SetUINT32(MF_MT_AUDIO_NUM_CHANNELS, channelCount);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeOut->SetUINT32(MF_MT_AUDIO_SAMPLES_PER_SECOND, bmdAudioSampleRate48kHz);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeOut->SetUINT32(MF_MT_AUDIO_BITS_PER_SAMPLE, bitsPerSample);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeOut->SetUINT32(MF_MT_AUDIO_AVG_BYTES_PER_SECOND, kAudioEncodedBitRate / 8);
	if (hr != S_OK)
		goto bail;

	hr = m_sinkWriter->AddStream(mediaTypeOut, &m_audioStreamIndex);
	if (hr != S_OK)
		goto bail;

	// Set the input audio media type.
	hr = MFCreateMediaType(&mediaTypeIn);
	if (hr != S_OK)
		goto bail;

	// Set attributes on the type.
	hr = mediaTypeIn->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeIn->SetGUID(MF_MT_SUBTYPE, MFAudioFormat_PCM);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeIn->SetUINT32(MF_MT_AUDIO_NUM_CHANNELS, channelCount);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeIn->SetUINT32(MF_MT_AUDIO_SAMPLES_PER_SECOND, bmdAudioSampleRate48kHz);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeIn->SetUINT32(MF_MT_AUDIO_BLOCK_ALIGNMENT, blockAlign);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeIn->SetUINT32(MF_MT_AUDIO_AVG_BYTES_PER_SECOND, bytesPerSecond);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeIn->SetUINT32(MF_MT_AUDIO_BITS_PER_SAMPLE, bitsPerSample);
	if (hr != S_OK)
		goto bail;

	hr = mediaTypeIn->SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
	if (hr != S_OK)
		goto bail;

	hr = m_sinkWriter->SetInputMediaType(m_audioStreamIndex, mediaTypeIn, NULL);

bail:
	return hr;
}
