/* -LICENSE-START-
** Copyright (c) 2019 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
#include "stdafx.h"
#include <stdint.h>
#include <comutil.h>
#include "DeckLinkInputDevice.h"


DeckLinkInputDevice::DeckLinkInputDevice(CComPtr<IDeckLink> device)
	: m_refCount(1), 
	m_deckLink(device), 
	m_videoFormatChangedCallback(nullptr),
	m_videoFrameArrivedCallback(nullptr),
	m_audioPacketArrivedCallback(nullptr),
	m_supportsFormatDetection(false), 
	m_currentlyCapturing(false),
	m_lastValidFrameStatus(DeviceStatus::InputSignalUnknown),
	m_applyDetectedInputMode(false)
{
}

HRESULT	STDMETHODCALLTYPE DeckLinkInputDevice::QueryInterface(REFIID iid, LPVOID *ppv)
{
	HRESULT result = E_NOINTERFACE;

	if (ppv == nullptr)
		return E_INVALIDARG;

	// Initialise the return result
	*ppv = nullptr;

	// Obtain the IUnknown interface and compare it the provided REFIID
	if (iid == IID_IUnknown)
	{
		*ppv = this;
		AddRef();
		result = S_OK;
	}
	else if (iid == IID_IDeckLinkInputCallback)
	{
		*ppv = (IDeckLinkInputCallback*)this;
		AddRef();
		result = S_OK;
	}
	else if (iid == IID_IDeckLinkNotificationCallback)
	{
		*ppv = (IDeckLinkNotificationCallback*)this;
		AddRef();
		result = S_OK;
	}

	return result;
}

ULONG STDMETHODCALLTYPE DeckLinkInputDevice::AddRef(void)
{
	return ++m_refCount;
}

ULONG STDMETHODCALLTYPE DeckLinkInputDevice::Release(void)
{
	ULONG newRefValue = --m_refCount;

	if (newRefValue == 0)
		delete this;

	return newRefValue;
}

bool DeckLinkInputDevice::Init()
{
	BSTR deviceNameBSTR = nullptr;

	// Get input interface
	m_deckLinkInput = m_deckLink;
	if (!m_deckLinkInput)
		return false;

	// Get attributes interface
	m_deckLinkAttributes = m_deckLink;
	if (!m_deckLinkAttributes)
		return false;

	// Check if input mode detection is supported.
	if (m_deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &m_supportsFormatDetection) != S_OK)
			m_supportsFormatDetection = FALSE;

	// Get configuration interface to allow changing of input connector
	// We hold onto IDeckLinkConfiguration for lifetime of DeckLinkDevice to retain input connector setting
	m_deckLinkConfig = m_deckLink;
	if (!m_deckLinkConfig)
		return false;

	// Get device name
	if (m_deckLink->GetDisplayName(&deviceNameBSTR) == S_OK)
	{
		m_deviceName = CString(deviceNameBSTR);
		::SysFreeString(deviceNameBSTR);
	}
	else
	{
		m_deviceName = _T("DeckLink");
	}

	// Get the profile manager interface
	// m_deckLinkProfileManager will be non-null when device has > 1 profiles
	m_deckLinkProfileManager = m_deckLink;

	return true;
}

bool DeckLinkInputDevice::StartCapture(BMDDisplayMode displayMode, BMDAudioSampleType audioSampleType, uint32_t audioChannelCount, IDeckLinkScreenPreviewCallback* screenPreviewCallback, IDeckLinkMemoryAllocator* allocator, bool applyDetectedInputMode)
{
	BMDVideoInputFlags videoInputFlags = bmdVideoInputFlagDefault;

	m_lastValidFrameStatus = DeviceStatus::InputSignalUnknown;

	m_applyDetectedInputMode = applyDetectedInputMode;

	// Enable input video mode detection if the device supports it
	if (m_supportsFormatDetection)
		videoInputFlags |= bmdVideoInputEnableFormatDetection;

	// Set the screen preview
	if (m_deckLinkInput->SetScreenPreviewCallback(screenPreviewCallback) != S_OK)
		return false;

	// Set the memory allocator
	if (m_deckLinkInput->SetVideoInputFrameMemoryAllocator(allocator) != S_OK)
		return false;

	// Set capture callback
	if (m_deckLinkInput->SetCallback(this) != S_OK)
		return false;

	// Set the video input mode
	if (m_deckLinkInput->EnableVideoInput(displayMode, bmdFormat8BitYUV, videoInputFlags) != S_OK)
		return false;

	// Enable audio input
	if (m_deckLinkInput->EnableAudioInput(bmdAudioSampleRate48kHz, audioSampleType, audioChannelCount) != S_OK)
		return false;

	// Start the capture
	if (m_deckLinkInput->StartStreams() != S_OK)
		return false;

	m_currentlyCapturing = true;

	return true;
}

void DeckLinkInputDevice::StopCapture()
{
	if (m_deckLinkInput != nullptr)
	{
		// Stop the capture
		m_deckLinkInput->StopStreams();

		// Disable video and audio inputs
		m_deckLinkInput->DisableVideoInput();
		m_deckLinkInput->DisableAudioInput();

		m_deckLinkInput->SetVideoInputFrameMemoryAllocator(nullptr);

		//
		m_deckLinkInput->SetScreenPreviewCallback(nullptr);

		// Delete capture callback
		m_deckLinkInput->SetCallback(nullptr);
	}

	m_currentlyCapturing = false;
}

bool DeckLinkInputDevice::RestartStreams()
{
	// Restart streams to reset stream time
	if (m_currentlyCapturing)
	{
		if (m_deckLinkInput->StopStreams() != S_OK)
			return false;

		if (m_deckLinkInput->FlushStreams() != S_OK)
			return false;

		if (m_deckLinkInput->StartStreams() != S_OK)
			return false;
	}

	return true;
}


HRESULT DeckLinkInputDevice::VideoInputFormatChanged(BMDVideoInputFormatChangedEvents notificationEvents, IDeckLinkDisplayMode *newMode, BMDDetectedVideoInputFormatFlags detectedSignalFlags)
{	
	BMDPixelFormat	pixelFormat = bmdFormat8BitYUV;

	// Restart capture with the new video mode if told to
	if (!m_applyDetectedInputMode)
		goto bail;

	// Restart capture with the new video mode if told to
	if (detectedSignalFlags & bmdDetectedVideoInputRGB444)
		pixelFormat = bmdFormat8BitBGRA;

	// Stop and flush the capture
	m_deckLinkInput->StopStreams();
	m_deckLinkInput->FlushStreams();

	// Set the video input mode
	if (m_deckLinkInput->EnableVideoInput(newMode->GetDisplayMode(), pixelFormat, bmdVideoInputEnableFormatDetection) != S_OK)
	{
		// Let the UI know we couldnt restart the capture with the detected input mode
		if (m_deviceStatusChangedCallback != nullptr)
			m_deviceStatusChangedCallback(DeviceStatus::ErrorRestartingCapture);
		goto bail;
	}

	// Start the capture
	if (m_deckLinkInput->StartStreams() != S_OK)
	{
		// Let the UI know we couldnt restart the capture with the detected input mode
		m_deviceStatusChangedCallback(DeviceStatus::ErrorRestartingCapture);
		goto bail;
	}		

	// Send event if colorspace has changed
	if ((notificationEvents & bmdVideoInputColorspaceChanged) &&
		((detectedSignalFlags & bmdDetectedVideoInputYCbCr422) || (detectedSignalFlags & bmdDetectedVideoInputRGB444)))
		if (m_pixelFormatChangedCallback != nullptr)
			m_pixelFormatChangedCallback(pixelFormat);

	// Send event with detected display mode
	if (notificationEvents & (bmdVideoInputDisplayModeChanged | bmdVideoInputFieldDominanceChanged))
		if (m_videoFormatChangedCallback != nullptr)
			m_videoFormatChangedCallback(newMode->GetDisplayMode());

bail:
	return S_OK;
}

HRESULT DeckLinkInputDevice::VideoInputFrameArrived(IDeckLinkVideoInputFrame* videoFrame, IDeckLinkAudioInputPacket* audioPacket)
{
	if (videoFrame != nullptr)
	{
		DeviceStatus validFrameStatus = (videoFrame->GetFlags() & bmdFrameHasNoInputSource) != 0 ? DeviceStatus::InputSignalInvalid : DeviceStatus::InputSignalValid;

		if ((validFrameStatus != m_lastValidFrameStatus) && (m_deviceStatusChangedCallback != nullptr))
			m_deviceStatusChangedCallback(validFrameStatus);

		m_lastValidFrameStatus = validFrameStatus;

		if (m_videoFrameArrivedCallback != nullptr)
		{
			CComPtr<IDeckLinkVideoInputFrame> inputFrame = videoFrame;
			m_videoFrameArrivedCallback(inputFrame);
		}
	}

	if (audioPacket != nullptr)
	{
		if (m_audioPacketArrivedCallback != nullptr)
		{
			CComPtr<IDeckLinkAudioInputPacket> inputPacket = audioPacket;
			m_audioPacketArrivedCallback(inputPacket);
		}
	}

	return S_OK;
}
