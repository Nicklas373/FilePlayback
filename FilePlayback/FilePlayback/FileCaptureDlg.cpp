/* -LICENSE-START-
** Copyright (c) 2019 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

// FileCaptureDlg.cpp : implementation file
//

#include "stdafx.h"
#include "mfapi.h"
#include <list>
#include "FileCapture.h"
#include "FileCaptureDlg.h"

static const std::list<std::pair<BMDVideoConnection, CString>> kInputConnections =
{
	{ bmdVideoConnectionSDI,		_T("SDI") },
	{ bmdVideoConnectionHDMI,		_T("HDMI") },
	{ bmdVideoConnectionOpticalSDI,	_T("Optical SDI") },
	{ bmdVideoConnectionComponent,	_T("Component") },
	{ bmdVideoConnectionComposite,	_T("Composite") },
	{ bmdVideoConnectionSVideo,		_T("S-Video") },
};

static const UINT kStatusBarIndicators[] =
{
	ID_SEPARATOR
};

// This is fixed (static) values to get 16 bit 48Khz output
static const BMDAudioSampleType		kAudioSampleDepth	= bmdAudioSampleType16bitInteger;
static const uint32_t				kAudioChannelCount	= 2;

CFileCaptureDlg::CFileCaptureDlg(CWnd* pParent)
: CDialog(CFileCaptureDlg::IDD, pParent), m_deckLinkDiscovery(nullptr),
m_selectedDevice(nullptr)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);	
}

void CFileCaptureDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_INPUT_DEVICE_COMBO, m_deviceListCombo);
	DDX_Control(pDX, IDC_INPUT_CONNECTION_COMBO, m_inputConnectionCombo);
	DDX_Control(pDX, IDC_INPUT_MODE_COMBO, m_modeListCombo);
	DDX_Control(pDX, IDC_AUTODETECT_FORMAT_CHECK, m_applyDetectedInputModeCheckbox);
	DDX_Control(pDX, IDC_RECORD_BUTTON, m_recordButton);
	DDX_Control(pDX, IDC_PREVIEW_BOX_FC, m_previewBox_fc);
}

BEGIN_MESSAGE_MAP(CFileCaptureDlg, CDialog)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_CLOSE()

	// UI element messages
	ON_BN_CLICKED(IDC_RECORD_BUTTON, &CFileCaptureDlg::OnRecordBnClicked)
	ON_CBN_SELCHANGE(IDC_INPUT_DEVICE_COMBO, &CFileCaptureDlg::OnNewDeviceSelected)
	ON_CBN_SELCHANGE(IDC_INPUT_CONNECTION_COMBO, &CFileCaptureDlg::OnInputConnectionSelected)
	ON_CBN_SELCHANGE(IDC_INPUT_MODE_COMBO, &CFileCaptureDlg::OnVideoModeSelected)
	ON_BN_CLICKED(IDC_AUTODETECT_FORMAT_CHECK, &CFileCaptureDlg::OnAutoDetectCBClicked)

	// Custom messages that impact UI
	ON_MESSAGE(WM_DETECT_VIDEO_MODE_MESSAGE, &CFileCaptureDlg::OnDetectVideoMode)
	ON_MESSAGE(WM_ADD_DEVICE_MESSAGE, &CFileCaptureDlg::OnAddDevice)
	ON_MESSAGE(WM_REMOVE_DEVICE_MESSAGE, &CFileCaptureDlg::OnRemoveDevice)
	ON_MESSAGE(WM_ERROR_RESTARTING_CAPTURE_MESSAGE, &CFileCaptureDlg::OnErrorRestartingCapture)
	ON_MESSAGE(WM_UPDATE_PROFILE_MESSAGE, &CFileCaptureDlg::OnProfileUpdate)
	ON_MESSAGE(WM_UPDATE_STREAM_TIME_MESSAGE, &CFileCaptureDlg::OnUpdateStreamTime)
	ON_MESSAGE(WM_SIGNAL_VALID_MESSAGE, &CFileCaptureDlg::OnSignalValid)
	ON_MESSAGE(WM_SIGNAL_INVALID_MESSAGE, &CFileCaptureDlg::OnSignalInvalid)

	//ON_STN_CLICKED(IDC_PREVIEW_BOX_FC, &CFileCaptureDlg::OnStnClickedPreviewBox)
END_MESSAGE_MAP()

void CFileCaptureDlg::OnRecordBnClicked()
{
	if (m_selectedDevice == nullptr)
		return;

	if (m_captureState == CaptureState::WaitingToRecord)
	{
		StartRecording();
	}
	else if (m_captureState == CaptureState::Recording)
	{
		StopRecording();
	}
}

void CFileCaptureDlg::OnNewDeviceSelected()
{
	int		selectedDeviceIndex;

	selectedDeviceIndex = m_deviceListCombo.GetCurSel();
	if (selectedDeviceIndex < 0)
		return;

	// Release profile callback from existing selected device
	if (m_selectedDevice != nullptr)
	{
		StopCapture();
		
		CComPtr<IDeckLinkProfileManager> profileManager = m_selectedDevice->GetDeviceProfileManager();
		if (profileManager != nullptr)
			profileManager->SetCallback(nullptr);

		m_selectedDevice.Release();
	}

	m_selectedDevice = (DeckLinkInputDevice*)m_deviceListCombo.GetItemDataPtr(selectedDeviceIndex);

	if (m_selectedDevice != nullptr)
	{
		// Register profile callback with newly selected device's profile manager
		CComPtr<IDeckLinkProfileManager> profileManager = m_selectedDevice->GetDeviceProfileManager();
		if (profileManager != nullptr)
			profileManager->SetCallback(m_profileCallback);

		// Enable auto-detect check-box by defualt if supported by device
		if (m_selectedDevice->SupportsFormatDetection())
			m_applyDetectedInputModeCheckbox.SetCheck(BST_CHECKED);
	}

	// Update the input video connections combo
	RefreshInputConnectionList();

	m_modeListCombo.EnableWindow(!(m_selectedDevice->SupportsFormatDetection()));
}

void CFileCaptureDlg::OnInputConnectionSelected()
{
	int selectedConnectionIndex;

	StopCapture();

	selectedConnectionIndex = m_inputConnectionCombo.GetCurSel();
	if (selectedConnectionIndex < 0)
		return;

	m_selectedInputConnection = (BMDVideoConnection)m_inputConnectionCombo.GetItemData(selectedConnectionIndex);

	// Configure input connection for selected device
	if (m_selectedDevice->GetDeckLinkConfiguration()->SetInt(bmdDeckLinkConfigVideoInputConnection, (int64_t)m_selectedInputConnection) != S_OK)
		return;

	// Updated video mode combo for selected input connection
	RefreshVideoModeList();
}

void CFileCaptureDlg::OnVideoModeSelected()
{
	if (m_applyDetectedInputModeCheckbox.GetCheck() == BST_UNCHECKED)
		StopCapture();

	if (!m_selectedDevice->IsCapturing())
		StartCapture();
}

void CFileCaptureDlg::OnAutoDetectCBClicked()
{
	StopCapture();

	m_modeListCombo.EnableWindow(m_selectedDevice && (m_applyDetectedInputModeCheckbox.GetCheck() == BST_UNCHECKED) ? TRUE : FALSE);

	StartCapture();
}

void CFileCaptureDlg::UpdateStatusBar(UINT frameCount = 0)
{
	CString statusBarString;

	switch (m_captureState)
	{
		case CaptureState::WaitingForDevice:
			statusBarString = _T("No device connected.");
			break;

		case CaptureState::WaitingForValidInput:
			statusBarString = _T("Invalid video signal.");
			break;

		case CaptureState::WaitingToRecord:
			statusBarString = _T("");
			break;

		case CaptureState::Recording:
			{
				UINT hours, minutes, seconds, frames;
				UINT maxFPS = (UINT)(m_timeScale / 1000);

				if (m_dropFrames)
				{
					UINT deciMins, deciMinsRemainder;

					UINT framesIn10mins = (UINT)((60 * 10 * maxFPS) - (9 * m_dropFrames));
					deciMins = frameCount / framesIn10mins;
					deciMinsRemainder = frameCount - (deciMins * framesIn10mins);

					// Add m_dropFrames for 9 minutes of every 10 minutes that have elapsed
					// AND m_dropFrames for every minute (over the first minute) in this 10-minute block.
					frameCount += m_dropFrames * 9 * deciMins;
					if (deciMinsRemainder >= m_dropFrames)
						frameCount += m_dropFrames * ((deciMinsRemainder - m_dropFrames) / (framesIn10mins / 10));
				}

				frames = frameCount % maxFPS;
				frameCount /= maxFPS;
				seconds = frameCount % 60;
				frameCount /= 60;
				minutes = frameCount % 60;
				frameCount /= 60;
				hours = frameCount;

				statusBarString.Format(_T("Recording - Duration %d:%02d:%02d:%03d"), hours, minutes, seconds, frames);
			}
			break;
	}
	m_statusBar.SetPaneText(0, statusBarString);
}

void CFileCaptureDlg::OnClose()
{
	// Stop the capture
	StopCapture();

	// Disable profile callback
	if (m_selectedDevice != nullptr)
	{
		if (m_selectedDevice->GetDeviceProfileManager() != nullptr)
		{
			m_selectedDevice->GetDeviceProfileManager()->SetCallback(nullptr);
		}
		m_selectedDevice.Release();
	}

	// Release profile callback
	m_profileCallback.Release();

	// Release all DeckLinkInputDevice instances
	for (int i = 0; i < m_deviceListCombo.GetCount(); i++)
	{
		CComPtr<DeckLinkInputDevice> device;
		device.Attach((DeckLinkInputDevice*)m_deviceListCombo.GetItemDataPtr(i));
		device.Release();
	}

	// Disable and release DeckLink device discovery
	m_deckLinkDiscovery->Disable();
	m_deckLinkDiscovery.Release();

	// Release preview window
	m_previewWindow_fc.Release();

	// Release sample queues and sink writer
	m_videoSampleQueue.Release();
	m_audioSampleQueue.Release();
	m_sinkWriter.Release();

	// Shutdown Media Foundation
	MFShutdown();

	CDialog::OnClose();
}


void CFileCaptureDlg::ShowErrorMessage(TCHAR* msg, TCHAR* title)
{
	MessageBox(msg, title);
}

void CFileCaptureDlg::RefreshInputConnectionList()
{
	LONGLONG	availableInputConnections;
	LONGLONG	currentInputConnection;
	int			index;

	m_inputConnectionCombo.ResetContent();

	// Get the available input video connections for the device
	if (m_selectedDevice->GetDeckLinkAttributes()->GetInt(BMDDeckLinkVideoInputConnections, &availableInputConnections) != S_OK)
		availableInputConnections = bmdVideoConnectionUnspecified;

	// Get the current selected input connection
	if (m_selectedDevice->GetDeckLinkConfiguration()->GetInt(bmdDeckLinkConfigVideoInputConnection, &currentInputConnection) != S_OK)
	{
		currentInputConnection = bmdVideoConnectionUnspecified;
	}

	for (auto connection : kInputConnections)
	{
		if ((connection.first & availableInputConnections) != 0)
		{
			// Input video connection is supported by device, add to combo
			index = m_inputConnectionCombo.AddString(connection.second);
			m_inputConnectionCombo.SetItemData(index, connection.first);

			// If input connection is the active connection set combo to this item
			if (connection.first == (BMDVideoConnection)currentInputConnection)
			{
				m_inputConnectionCombo.SetCurSel(index);
				OnInputConnectionSelected();
			}
		}
	}

	// If no input connection has been selected, select first index
	index = m_inputConnectionCombo.GetCurSel();
	if ((index == CB_ERR) && (m_inputConnectionCombo.GetCount() > 0))
	{
		m_inputConnectionCombo.SetCurSel(0);
		OnInputConnectionSelected();
	}
}

void CFileCaptureDlg::RefreshVideoModeList()
{
	// Populate the display mode menu with a list of display modes supported by the installed DeckLink card
	CComPtr<IDeckLinkDisplayModeIterator>	displayModeIterator;
	CComPtr<IDeckLinkDisplayMode>			deckLinkDisplayMode;
	CComQIPtr<IDeckLinkStatus>				deckLinkStatus = m_selectedDevice->GetDeckLinkInstance();
	LONGLONG								currentVideoInputMode;
	int										index;

	// Clear the menu
	m_modeListCombo.ResetContent();

	// Get the current input video mode status
	if (deckLinkStatus->GetInt(bmdDeckLinkStatusCurrentVideoInputMode, &currentVideoInputMode) != S_OK)
		currentVideoInputMode = bmdModeNTSC;

	VideoFormatChanged((BMDDisplayMode)currentVideoInputMode);

	if (m_selectedDevice->GetDeckLinkInput()->GetDisplayModeIterator(&displayModeIterator) != S_OK)
		return;

	while (displayModeIterator->Next(&deckLinkDisplayMode) == S_OK)
	{
		BSTR	modeName;
		HRESULT hr			= E_FAIL;
		BOOL	supported;

		// Check that display mode is supported with the active profile
		hr = m_selectedDevice->GetDeckLinkInput()->DoesSupportVideoMode(m_selectedInputConnection, deckLinkDisplayMode->GetDisplayMode(), bmdFormatUnspecified, bmdSupportedVideoModeDefault, &supported);
		if (hr != S_OK || !supported)
		{
			deckLinkDisplayMode.Release();
			continue;
		}

		if (deckLinkDisplayMode->GetName(&modeName) != S_OK)
		{
			deckLinkDisplayMode.Release();
			continue;
		}

		// Add this item to the video format popup menu
		index = m_modeListCombo.AddString(modeName);

		// Save the BMDDisplayMode in the menu item's tag
		m_modeListCombo.SetItemData(index, deckLinkDisplayMode->GetDisplayMode());

		// If this display mode is the current video input mode set combo to this item
		if (deckLinkDisplayMode->GetDisplayMode() == m_displayMode)
		{
			m_modeListCombo.SetCurSel(index);
			OnVideoModeSelected();
		}

		deckLinkDisplayMode.Release();
		SysFreeString(modeName);
	}

	// If no video mode has been selected, select first index
	index = m_modeListCombo.GetCurSel();
	if ((index == CB_ERR) && (m_modeListCombo.GetCount() > 0))
	{
		m_modeListCombo.SetCurSel(0);
		OnVideoModeSelected();
	}

	UpdateInterface();
}

void CFileCaptureDlg::VideoFormatChanged(BMDDisplayMode videoFormat) 
{
	CComPtr<IDeckLinkDisplayMode>	displayMode;

	m_displayMode = videoFormat;

	// Get frame rate for detected mode 
	if (m_selectedDevice->GetDeckLinkInput()->GetDisplayMode(m_displayMode, &displayMode) == S_OK)
	{
		displayMode->GetFrameRate(&m_frameDuration, &m_timeScale);

		// Frame rates of 30/1.001, 60/1.001, etc can implement drop frames (SMPTE 12-1)
		m_dropFrames = ((UINT)m_frameDuration == 1001) && ((UINT)m_timeScale % 30000 == 0) ? 2 * ((UINT)m_timeScale / 30000) : 0;

		m_videoSampleQueue->SetVideoInterlacedMode(displayMode->GetFieldDominance() != bmdProgressiveFrame);
	}

	// Update UI with detected video format
	PostMessage(WM_DETECT_VIDEO_MODE_MESSAGE, 0, (LPARAM)videoFormat);
}

void CFileCaptureDlg::StartCapture()
{
	int		selectedVideoFormatIndex	= m_modeListCombo.GetCurSel();
	bool	applyDetectedInputMode		= (m_applyDetectedInputModeCheckbox.GetCheck() == BST_CHECKED);

	if (selectedVideoFormatIndex < 0)
		return;

	if (m_selectedDevice && 
		m_selectedDevice->StartCapture((BMDDisplayMode)m_modeListCombo.GetItemData(selectedVideoFormatIndex), kAudioSampleDepth, kAudioChannelCount, m_previewWindow_fc, m_videoSampleQueue, applyDetectedInputMode))
	{
		m_captureState = CaptureState::WaitingForValidInput;
		UpdateStatusBar();
	}
	else
	{
		ShowErrorMessage(_T("This application was unable to select the chosen video mode. Perhaps, the selected device is currently in use."), _T("Error starting video capture"));
	}
}

void CFileCaptureDlg::StopCapture()
{
	if ((m_selectedDevice) && (m_selectedDevice->IsCapturing()))
		m_selectedDevice->StopCapture();

	m_captureState = CaptureState::WaitingForValidInput;
	UpdateInterface();
}

void CFileCaptureDlg::StartRecording()
{
	TCHAR							tempPathBuffer[MAX_PATH];
	DWORD							tempPathSize;
	CComPtr<IDeckLinkDisplayMode>	displayMode;

	m_frameCount = 0;

	// Get temp path from environment variable.
	tempPathSize = GetTempPath(MAX_PATH, tempPathBuffer);
	if ((tempPathSize > MAX_PATH) || (tempPathSize == 0))
	{
		ShowErrorMessage(_T("Unable to get temporary path"), _T("Error"));
		return;
	}

	// Generate temporary filename
	if (GetTempFileName(tempPathBuffer, _T("MOV"), 0, m_tempFileName) == 0)
	{
		ShowErrorMessage(_T("Unable to generate temporary file"), _T("Error"));
		return;
	}

	PathRenameExtension(m_tempFileName, L".mp4");

	if (m_selectedDevice->GetDeckLinkInput()->GetDisplayMode(m_displayMode, &displayMode) != S_OK)
	{
		ShowErrorMessage(_T("Unable to get dispay mode"), _T("Error"));
		return;
	}

	if (m_sinkWriter->Initialize(displayMode, m_pixelFormat, kAudioSampleDepth, kAudioChannelCount, CString(m_tempFileName)) != S_OK)
	{
		ShowErrorMessage(_T("Unable to initialize sink writer"), _T("Error"));
		return;
	}

	if (!m_selectedDevice->RestartStreams())
	{
		ShowErrorMessage(_T("Unable to restart input streams"), _T("Error"));
		return;
	}

	// Start Media Sink Writer thread
	m_sinkWriterThread = std::thread(&SinkWriter::SinkWriterThread, m_sinkWriter, m_videoSampleQueue, m_audioSampleQueue);

	m_captureState = CaptureState::Recording;
	UpdateInterface();
}

void CFileCaptureDlg::StopRecording()
{
	CComPtr<IFileSaveDialog>	fileSave;
	CComPtr<IShellItem>			item;
	PWSTR						pszFilePath = NULL;
	HRESULT						hr;

	const COMDLG_FILTERSPEC filterSpec[] =
	{
		{ L"MP4 Files", L"*.mp4" },
		{ L"All files", L"*.*" }
	};

	m_captureState = CaptureState::WaitingToRecord;

	// Stop video and audio sample queues, this will cancel waiting threads in SinkWriter
	m_videoSampleQueue->CancelCapture();
	m_audioSampleQueue->CancelCapture();

	// Wait for sink writer thread to complete
	m_sinkWriterThread.join();

	m_videoSampleQueue->Reset();
	m_audioSampleQueue->Reset();

	// Create the FileOpenDialog object.
	hr = fileSave.CoCreateInstance(__uuidof(FileSaveDialog), NULL, CLSCTX_INPROC_SERVER);
	if (hr != S_OK)
	{
		goto bail;
	}

	hr = fileSave->SetFileTypes((sizeof(filterSpec) / sizeof(filterSpec[0])), filterSpec);
	if (hr != S_OK)
	{
		goto bail;
	}

	// Show the Save dialog box.
	hr = fileSave->Show(NULL);
	if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))
	{
		// The user canceled the dialog. Do not treat as an error.
		hr = S_OK;
		goto bail;
	}
	else if (hr != S_OK)
	{
		goto bail;
	}

	// Get the file name from the dialog box.
	hr = fileSave->GetResult(&item);
	if (hr != S_OK)
	{
		goto bail;
	}

	hr = item->GetDisplayName(SIGDN_FILESYSPATH, &pszFilePath);
	if (hr != S_OK)
	{
		goto bail;
	}

	PathRenameExtension(pszFilePath, L".mp4");

	if (!MoveFileEx(m_tempFileName, pszFilePath, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))
		hr = E_FAIL;

bail:
	if (PathFileExists(m_tempFileName))
		(void)DeleteFile(m_tempFileName);

	if (hr != S_OK)
	{
		MessageBox(_T("Cannot save this file."), _T("Error"));
	}
	CoTaskMemFree(pszFilePath);

	UpdateInterface();
}

void CFileCaptureDlg::UpdateInterface()
{
	BOOL enabled = (m_captureState == CaptureState::WaitingForValidInput) || (m_captureState == CaptureState::WaitingToRecord) ? TRUE : FALSE;

	m_deviceListCombo.EnableWindow(enabled);
	m_inputConnectionCombo.EnableWindow(enabled && m_selectedDevice);
	m_modeListCombo.EnableWindow(enabled && m_selectedDevice && (m_applyDetectedInputModeCheckbox.GetCheck() == BST_UNCHECKED));
	m_applyDetectedInputModeCheckbox.EnableWindow(enabled && m_selectedDevice && m_selectedDevice->SupportsFormatDetection());

	if (!m_selectedDevice || !m_selectedDevice->SupportsFormatDetection())
		m_applyDetectedInputModeCheckbox.SetCheck(BST_UNCHECKED);

	m_recordButton.EnableWindow(((m_captureState == CaptureState::WaitingToRecord) || (m_captureState == CaptureState::Recording)) && (m_modeListCombo.GetCount() > 0) ? TRUE : FALSE);
	m_recordButton.SetWindowText(m_captureState == CaptureState::Recording ? _T("Stop Record") : _T("Start Record"));

	UpdateStatusBar();
}

BOOL	CFileCaptureDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	SetIcon(m_hIcon, FALSE);

	m_captureState = CaptureState::WaitingForDevice;

	// Base on default values for NTSC
	m_dropFrames = 2;
	m_displayMode = bmdModeNTSC;
	m_pixelFormat = bmdFormat8BitYUV;
	m_frameDuration = 1001;
	m_timeScale = 30000;
	m_frameCount = 0;

	// Start Media Foundation
	if (MFStartup(MF_VERSION) != S_OK)
	{
		TRACE0("Failed to start Media Foundation\n");
		return -1;      // fail to create
	}

	if (!m_statusBar.Create(this))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}
	m_statusBar.SetIndicators(kStatusBarIndicators, sizeof(kStatusBarIndicators) / sizeof(UINT));
	RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, ID_SEPARATOR);
	UpdateStatusBar();

	// Empty popup menus
	m_deviceListCombo.ResetContent();
	m_modeListCombo.ResetContent();

	// Disable the interface
	UpdateInterface();

	// Create Sink writer 
	m_sinkWriter.Attach(new SinkWriter());

	// Generate queues for incoming video frames and audio packets
	m_videoSampleQueue.Attach(new SampleMemoryAllocator());
	m_audioSampleQueue.Attach(new AudioSampleQueue(kAudioChannelCount, kAudioSampleDepth));

	// Create and initialize preview helper
	m_previewWindow_fc.Attach(new PreviewWindow());
	if (m_previewWindow_fc->Initialize(&m_previewBox_fc) == false)
	{
		ShowErrorMessage(_T("This application was unable to initialise the preview window"), _T("Error"));
		goto bail;
	}

	m_profileCallback.Attach(new ProfileCallback());

	m_profileCallback->OnHaltStreams(std::bind(&CFileCaptureDlg::StopCapture, this));

	m_profileCallback->OnProfileActivated([this](void) {
		// Update UI with new profile
		PostMessage(WM_UPDATE_PROFILE_MESSAGE, 0, 0);
	});

	m_deckLinkDiscovery.Attach(new DeckLinkDeviceDiscovery());
	if (!m_deckLinkDiscovery || (!m_deckLinkDiscovery->Enable()))
	{
		ShowErrorMessage(_T("Please install the Blackmagic Desktop Video drivers to use the features of this application."), _T("This application requires the Desktop Video drivers installed."));
		goto bail;
	}

	m_deckLinkDiscovery->OnDeviceArrival([this](CComPtr<IDeckLink> &dl) {
		// Update UI (add new device to menu) from main thread
		PostMessage(WM_ADD_DEVICE_MESSAGE, (WPARAM)dl.Detach(), 0);
	});

	m_deckLinkDiscovery->OnDeviceRemoval([this](CComPtr<IDeckLink> &dl) {
		// Update UI (remove device from menu) from main thread
		PostMessage(WM_REMOVE_DEVICE_MESSAGE, (WPARAM)dl.Detach(), 0);
		dl.Release();
	});

bail:
	return TRUE;
}

void CFileCaptureDlg::AddDevice(CComPtr<IDeckLink> deckLink)
{	
	int								deviceIndex;
	CComPtr<DeckLinkInputDevice>	newDevice;
		
	newDevice.Attach(new DeckLinkInputDevice(deckLink));

	// Initialise new DeckLinkDevice object
	if (!newDevice->Init())
	{
		return;
	}

	// Register callback handlers
	newDevice->OnVideoFormatChange(std::bind(&CFileCaptureDlg::VideoFormatChanged, this, std::placeholders::_1));

	newDevice->OnPixelFormatChange([this](BMDPixelFormat pf) { m_pixelFormat = pf; });

	newDevice->OnVideoFrameArrival([this](CComPtr<IDeckLinkVideoInputFrame> frame) {
		if (m_captureState == CaptureState::Recording)
		{
			m_videoSampleQueue->VideoFrameArrived(frame);

			// Update UI with recording stream time
			PostMessage(WM_UPDATE_STREAM_TIME_MESSAGE, 0, 0);
		}
	});

	newDevice->OnDeviceStatusChange([this](DeviceStatus status) {
		switch (status)
		{
			case DeviceStatus::InputSignalInvalid:
				PostMessage(WM_SIGNAL_INVALID_MESSAGE, 0, 0);
				break;

			case DeviceStatus::InputSignalValid:
				PostMessage(WM_SIGNAL_VALID_MESSAGE, 0, 0);
				break;
				
			case DeviceStatus::ErrorRestartingCapture:
				PostMessage(WM_ERROR_RESTARTING_CAPTURE_MESSAGE, 0, 0);
				break;
		}
	});

	newDevice->OnAudioPacketArrival([this](CComPtr<IDeckLinkAudioInputPacket> packet) {
		if (m_captureState == CaptureState::Recording)
			m_audioSampleQueue->AudioPacketArrived(packet);
	});

	// Add this DeckLink device to the device list
	deviceIndex = m_deviceListCombo.AddString(newDevice->GetDeviceName());
	if (deviceIndex < 0)
		return;

	m_deviceListCombo.SetItemDataPtr(deviceIndex, (void*)newDevice.Detach());

	if (m_captureState == CaptureState::WaitingForDevice)
	{
		// We have added our first item, refresh and enable UI
		m_deviceListCombo.SetCurSel(0);
		OnNewDeviceSelected();

		m_captureState = CaptureState::WaitingForValidInput;
		UpdateInterface();
	}
}

void CFileCaptureDlg::RemoveDevice(CComPtr<IDeckLink> deckLink)
{
	int deviceIndex = -1;
	CComPtr<DeckLinkInputDevice> deviceToRemove  = nullptr;

	// Find the combo box entry to remove (there may be multiple entries with the same name, but each
	// will have a different data pointer).
	for (deviceIndex = 0; deviceIndex < m_deviceListCombo.GetCount(); ++deviceIndex)
	{
		deviceToRemove = (DeckLinkInputDevice*)m_deviceListCombo.GetItemDataPtr(deviceIndex);
		if (deviceToRemove->GetDeckLinkInstance() == deckLink)
			break;
	}

	if (deviceToRemove == nullptr)
		return;

	// Stop capturing before removal
	if (deviceToRemove->IsCapturing())
		deviceToRemove->StopCapture();

	// Remove device from list
	m_deviceListCombo.DeleteString(deviceIndex);

	// Refresh UI
	m_recordButton.SetWindowText(_T("Start record"));

	// Check how many devices are left
	if (m_deviceListCombo.GetCount() == 0)
	{
		// We have removed the last device, disable the interface.
		m_captureState = CaptureState::WaitingForDevice;
		UpdateInterface();
		m_selectedDevice = nullptr;
	}
	else if (m_selectedDevice == deviceToRemove)
	{
		// The device that was removed was the one selected in the UI.
		// Select the first available device in the list and reset the UI.
		m_deviceListCombo.SetCurSel(0);
		OnNewDeviceSelected();
	}
}

LRESULT CFileCaptureDlg::OnDetectVideoMode(WPARAM wParam, LPARAM lParam)
{
	// A new video mode was auto-detected, update the video mode combo box
	for (int i = 0; i < m_modeListCombo.GetCount(); i++)
	{
		if (m_modeListCombo.GetItemData(i) == (BMDDisplayMode)lParam)
		{
			m_modeListCombo.SetCurSel(i);
			break;
		}
	}

	return 0;
}

LRESULT CFileCaptureDlg::OnAddDevice(WPARAM wParam, LPARAM lParam)
{
	// A new device has been connected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	AddDevice(deckLink);
	return 0;
}

LRESULT	CFileCaptureDlg::OnRemoveDevice(WPARAM wParam, LPARAM lParam)
{
	// An existing device has been disconnected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	RemoveDevice(deckLink);
	return 0;
}

LRESULT	CFileCaptureDlg::OnErrorRestartingCapture(WPARAM wParam, LPARAM lParam)
{
	// A change in the input video mode was detected, but the capture could not be restarted.
	StopCapture();
	ShowErrorMessage(_T("This application was unable to apply the detected input video mode."), _T("Error restarting the capture."));
	return 0;
}

LRESULT CFileCaptureDlg::OnProfileUpdate(WPARAM wParam, LPARAM lParam)
{
	// Update input video connection combo with new profile
	RefreshInputConnectionList();
	return 0;
}

LRESULT CFileCaptureDlg::OnUpdateStreamTime(WPARAM wParam, LPARAM lParam)
{
	UpdateStatusBar(++m_frameCount);
	return 0;
}

LRESULT CFileCaptureDlg::OnSignalValid(WPARAM wParam, LPARAM lParam)
{
	if (m_captureState == CaptureState::WaitingForValidInput)
		m_captureState = CaptureState::WaitingToRecord;
	UpdateInterface();

	return 0;
}

LRESULT CFileCaptureDlg::OnSignalInvalid(WPARAM wParam, LPARAM lParam)
{
	if (m_captureState == CaptureState::WaitingToRecord)
		m_captureState = CaptureState::WaitingForValidInput;
	else if (m_captureState == CaptureState::Recording)
	{
		StopRecording();
		m_captureState = CaptureState::WaitingForValidInput;
	}
	UpdateInterface();

	return 0;
}

void CFileCaptureDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CFileCaptureDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}