/* -LICENSE-START-
** Copyright (c) 2019 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "stdafx.h"
#include "mfapi.h"
#include "SampleQueue.h"
#include "SampleMemoryAllocator.h"

SampleMemoryAllocator::SampleMemoryAllocator()
	: m_refCount(1), 
	m_cancelCapture(false),
	m_videoInterlaced(FALSE)
{
}

// IUnknown methods

HRESULT SampleMemoryAllocator::QueryInterface(REFIID iid, LPVOID* ppv)
{
	*ppv = nullptr;
	return E_NOTIMPL;
}

ULONG SampleMemoryAllocator::AddRef(void)
{
	return ++m_refCount;
}

ULONG SampleMemoryAllocator::Release(void)
{
	ULONG newRefValue = --m_refCount;

	if (newRefValue == 0)
		delete this;

	return newRefValue;
}

// IDeckLinkMemoryAllocator methods

HRESULT SampleMemoryAllocator::AllocateBuffer(unsigned int bufferSize, void** allocatedBuffer)
{
	CComPtr<IMFMediaBuffer> mediaBuffer;

	// Create memory buffer aligned to 64-byte boundary
	if (MFCreateAlignedMemoryBuffer(bufferSize, MF_64_BYTE_ALIGNMENT, &mediaBuffer) != S_OK)
		return E_OUTOFMEMORY;

	// Lock buffer so pointer is accessible to DeckLinkAPI
	if (mediaBuffer->Lock((BYTE**)allocatedBuffer, nullptr, nullptr) != S_OK)
		return E_OUTOFMEMORY;

	m_allocatedBuffers[*allocatedBuffer] = mediaBuffer;

	return S_OK;
}

HRESULT SampleMemoryAllocator::ReleaseBuffer(void* buffer)
{
	auto mediaBufferIter = m_allocatedBuffers.find(buffer);

	if (mediaBufferIter == m_allocatedBuffers.end())
		// Did not find buffer
		return E_FAIL;

	// Unlock buffer if not already done so
	mediaBufferIter->second->Unlock();

	m_allocatedBuffers.erase(mediaBufferIter);

	return S_OK;
}

HRESULT SampleMemoryAllocator::Commit()
{
	return S_OK;
}

HRESULT SampleMemoryAllocator::Decommit()
{
	return S_OK;
}

bool SampleMemoryAllocator::WaitForInputSample(IMFSample** sample, bool& waitCancelled)
{
	CComPtr<IMFSample>					videoSample;
	CComPtr<IDeckLinkVideoInputFrame>	videoFrame;
	void*								videoBuffer;
	BMDTimeValue						frameTime;
	BMDTimeValue						frameDuration;
	HRESULT								hr = S_OK;

	{
		std::unique_lock<std::mutex> lock(m_videoFrameQueueMutex);
		m_videoFrameQueueCondition.wait(lock, [&]{ return !m_videoFrameQueue.empty() || m_cancelCapture; });

		if (!m_videoFrameQueue.empty())
		{
			videoFrame = m_videoFrameQueue.front();
			m_videoFrameQueue.pop();
		}	
	}

	if (videoFrame != nullptr)
	{
		// Get time and duration of captured frame
		hr = videoFrame->GetStreamTime(&frameTime, &frameDuration, kMFTimescale);
		if (hr != S_OK)
			goto bail;

		// Get pointer to video buffer to match to IMFMediaBuffer
		hr = videoFrame->GetBytes(&videoBuffer);
		if (hr != S_OK)
			goto bail;

		auto mediaBufferIter = m_allocatedBuffers.find(videoBuffer);
		if (mediaBufferIter == m_allocatedBuffers.end())
			// Did not find buffer
			return false;

		// Found IMFMediaBuffer, unlock and construct IMFSample
		mediaBufferIter->second->Unlock();

		// Set the data length of the buffer.
		hr = mediaBufferIter->second->SetCurrentLength(videoFrame->GetRowBytes() * videoFrame->GetHeight());
		if (hr != S_OK)
			goto bail;

		// Create a media sample and add the buffer to the sample.
		hr = MFCreateSample(&videoSample);
		if (hr != S_OK)
			goto bail;

		hr = videoSample->AddBuffer(mediaBufferIter->second);
		if (hr != S_OK)
			goto bail;

		// Set the time stamp and the duration.
		hr = videoSample->SetSampleTime((LONGLONG)frameTime);
		if (hr != S_OK)
			goto bail;
		
		hr = videoSample->SetSampleDuration((LONGLONG)frameDuration);
		if (hr != S_OK)
			goto bail;

		hr = videoSample->SetUINT32(MFSampleExtension_Interlaced, m_videoInterlaced);
		if (hr != S_OK)
			goto bail;

		*sample = videoSample.Detach();
	}

bail:
	waitCancelled = m_cancelCapture;

	return (hr == S_OK);
}

void SampleMemoryAllocator::VideoFrameArrived(CComPtr<IDeckLinkVideoInputFrame> frame)
{
	{
		std::lock_guard<std::mutex> lock(m_videoFrameQueueMutex);
		m_videoFrameQueue.push(frame);
	}
	m_videoFrameQueueCondition.notify_one();
}

void SampleMemoryAllocator::CancelCapture()
{
	{
		// signal cancel flag to terminate wait condition
		std::lock_guard<std::mutex> lock(m_videoFrameQueueMutex);
		m_cancelCapture = true;
	}
	m_videoFrameQueueCondition.notify_one();
}

void SampleMemoryAllocator::Reset()
{
	std::lock_guard<std::mutex> lock(m_videoFrameQueueMutex);
	m_cancelCapture = false;
}
