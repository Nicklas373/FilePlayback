/* -LICENSE-START-
** Copyright (c) 2019 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "stdafx.h"
#include <comutil.h>
#include <functional>
#include <thread>
#include "PlaybackVideoFrame.h"
#include "PlaybackAudioPacket.h"
#include "DeckLinkOutputDevice.h"

static const BMDPixelFormat kConvertedPixelFormat = bmdFormat10BitYUV;

DeckLinkOutputDevice::DeckLinkOutputDevice(CComPtr<IDeckLink> deckLink) :
	m_refCount(1),
	m_deckLink(deckLink),
	m_deckLinkOutput(nullptr),
	m_deckLinkStatus(nullptr),
	m_deckLinkNotification(nullptr),
	m_deckLinkProfileManager(nullptr),
	m_deckLinkFrameConverter(nullptr),
	m_outputWithConversion(false),
	m_bufferedVideoFrameCount(0),
	m_bufferedAudioSampleCount(0),
	m_prerollingAudio(false),
	m_bufferedAudioWaterLevel(0),
	m_bufferedVideoWaterLevel(0),
	m_endOfStream(false),
	m_currentStreamTime(0),
	m_scheduledStartTime(0),
	m_scheduledStopTime(0)
{
}

bool DeckLinkOutputDevice::Initialize()
{
	// Get output interface
	m_deckLinkOutput = m_deckLink;
	if (!m_deckLinkOutput)
		return false;

	// Get DeckLink Status interface to notify on output mode changes
	m_deckLinkStatus = m_deckLink;
	if (!m_deckLinkStatus)
		return false;

	// Get DeckLink notification interface and register callback
	m_deckLinkNotification = m_deckLink;
	if (!m_deckLinkNotification || (m_deckLinkNotification->Subscribe(bmdStatusChanged, this) != S_OK))
		return false;

	// Get the profile manager interface
	// m_deckLinkProfileManager will be nullptr when there is only 1 profile
	m_deckLinkProfileManager = m_deckLink;

	// Get DeckLink Video Conversion interface for when requested pixel format is not supported by device 
	if (m_deckLinkFrameConverter.CoCreateInstance(CLSID_CDeckLinkVideoConversion, nullptr, CLSCTX_ALL) != S_OK)
		return false;

	return true;
}

bool DeckLinkOutputDevice::Uninitialize()
{
	// Unsubscribe to release notification reference
	if (m_deckLinkNotification)
		return (m_deckLinkNotification->Unsubscribe(bmdStatusChanged, this) == S_OK);

	return true;
}

HRESULT	DeckLinkOutputDevice::QueryInterface(REFIID iid, LPVOID *ppv)
{
	HRESULT			result = E_NOINTERFACE;

	if (ppv == nullptr)
		return E_INVALIDARG;

	// Initialise the return result
	*ppv = nullptr;

	// Obtain the IUnknown interface and compare it the provided REFIID
	if (iid == IID_IUnknown)
	{
		*ppv = this;
		AddRef();
		result = S_OK;
	}
	else if (iid == IID_IDeckLinkDeviceNotificationCallback)
	{
		*ppv = (IDeckLinkDeviceNotificationCallback*)this;
		AddRef();
		result = S_OK;
	}

	return result;
}

ULONG DeckLinkOutputDevice::AddRef(void)
{
	return ++m_refCount;
}

ULONG DeckLinkOutputDevice::Release(void)
{
	ULONG newRefValue = --m_refCount;
	if (newRefValue == 0)
		delete this;

	return newRefValue;
}

HRESULT	DeckLinkOutputDevice::ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult result)
{
	HRESULT hr = S_OK;

	if (completedFrame)
	{
		if (result == bmdOutputFrameDisplayedLate)
		{
			// Output frame scheduling has fallen behind frame rate, stop playback and notify UI
			StopScheduledPlayback();

			if (m_frameDisplayedLateCallback != nullptr)
				m_frameDisplayedLateCallback();
		}

		if ((result != bmdOutputFrameFlushed) && (m_updateStreamTimeCallback != nullptr))
		{
			// Get stream time to update UI
			if (m_deckLinkOutput->GetScheduledStreamTime(m_frameTimescale, &m_currentStreamTime, nullptr) == S_OK)
				m_updateStreamTimeCallback();
		}
	}

	// Get buffered video frame count and update thread
	{
		std::lock_guard<std::mutex> lock(m_playbackMutex);
		hr = m_deckLinkOutput->GetBufferedVideoFrameCount(&m_bufferedVideoFrameCount);
	}
			
	if (hr == S_OK)
		m_scheduleVideoFrameCondition.notify_one();

	return hr;
}

HRESULT	DeckLinkOutputDevice::ScheduledPlaybackHasStopped()
{
	// Notify subscribers that playback has stopped, so it can disable output
	if (m_scheduledPlaybackStoppedCallback != nullptr)
		m_scheduledPlaybackStoppedCallback(m_endOfStream);

	return S_OK;
}

HRESULT	DeckLinkOutputDevice::RenderAudioSamples(BOOL preroll)
{
	{
		std::lock_guard<std::mutex> lock(m_playbackMutex);
		if (m_deckLinkOutput->GetBufferedAudioSampleFrameCount(&m_bufferedAudioSampleCount) != S_OK)
			return E_FAIL;

		if (m_bufferedAudioSampleCount > m_bufferedAudioWaterLevel)
		{
			if (m_prerollingAudio)
			{
				// Ensure that video preroll is also complete, then commence scheduled playback
				if (m_bufferedVideoFrameCount >= m_bufferedVideoWaterLevel)
				{
					m_deckLinkOutput->EndAudioPreroll();
					m_prerollingAudio = false;

					if (m_deckLinkOutput->StartScheduledPlayback(m_scheduledStartTime, m_frameTimescale, 1.0) != S_OK)
						return E_FAIL;
				}
			}
			return S_OK;
		}
	}

	m_scheduleAudioPacketCondition.notify_one();

	return S_OK;
}

HRESULT DeckLinkOutputDevice::Notify(BMDNotifications topic, ULONGLONG param1, ULONGLONG param2)
{
	if ((topic == bmdStatusChanged) && ((BMDDeckLinkStatusID)param1 == bmdDeckLinkStatusBusy))
	{
		int64_t busyStatus;
		if ((m_deckLinkStatus->GetInt(bmdDeckLinkStatusBusy, &busyStatus) == S_OK) && (m_outputStateChangeCallback != nullptr))
			m_outputStateChangeCallback((busyStatus & bmdDevicePlaybackBusy) != 0);
	}

	return S_OK;
}


HRESULT DeckLinkOutputDevice::GetDeviceName(CString& deviceName) 
{ 
	CComBSTR	deviceNameBSTR = nullptr;
	HRESULT		hr;

	hr = m_deckLink->GetDisplayName(&deviceNameBSTR);
	if (hr == S_OK)
		deviceName = CString(deviceNameBSTR);
	else
		deviceName = _T("DeckLink");

	return hr; 
};

HRESULT DeckLinkOutputDevice::GetDisplayModeName(CString& displayModeName)
{
	HRESULT							hr;
	int64_t							displayModeInt;
	CComPtr<IDeckLinkDisplayMode>	displayMode;
	CComBSTR						displayModeString;

	if (!displayModeName.IsEmpty())
		return E_INVALIDARG;

	hr = m_deckLinkStatus->GetInt(bmdDeckLinkStatusCurrentVideoOutputMode, &displayModeInt);
	if (hr != S_OK)
		goto bail;

	hr = m_deckLinkOutput->GetDisplayMode((BMDDisplayMode)displayModeInt, &displayMode);
	if (hr != S_OK)
		goto bail;

	hr = displayMode->GetName(&displayModeString);
	if (hr != S_OK)
		goto bail;

bail:
	if (hr == S_OK)
		displayModeName = CString(displayModeString);
	else
		displayModeName = _T("");
	return hr;
}

BMDTimeValue DeckLinkOutputDevice::GetCurrentStreamTime(BMDTimeScale timescale)
{
	return m_currentStreamTime * timescale / m_frameTimescale;
}


bool DeckLinkOutputDevice::EnableOutput(BMDDisplayMode displayMode, BMDPixelFormat pixelFormat, BMDAudioSampleType audioSampleType, uint32_t audioChannelCount, IDeckLinkScreenPreviewCallback* screenPreviewCallback)
{
	CComPtr<IDeckLinkDisplayMode>	deckLinkDisplayMode;
	BOOL							displayModeSupported;

	if ((m_deckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, displayMode, pixelFormat, bmdNoVideoOutputConversion, bmdSupportedVideoModeDefault, nullptr, &displayModeSupported) != S_OK) ||
		!displayModeSupported)
	{
		// Video mode is unsupported, check whether we can support with format conversion
		if ((m_deckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, displayMode, kConvertedPixelFormat, bmdNoVideoOutputConversion, bmdSupportedVideoModeDefault, nullptr, &displayModeSupported) != S_OK) ||
			!displayModeSupported)
			return false;

		m_outputWithConversion = true;
	}
	else
		m_outputWithConversion = false;

	if (m_deckLinkOutput->GetDisplayMode(displayMode, &deckLinkDisplayMode) != S_OK)
		return false;

	if (deckLinkDisplayMode->GetFrameRate(&m_frameDuration, &m_frameTimescale) != S_OK)
		return false;

	// Preroll 1/2 second of video
	m_bufferedVideoWaterLevel = (uint32_t)((m_frameTimescale / m_frameDuration) / 2);
	m_bufferedAudioWaterLevel = (uint32_t)(((int64_t)(m_bufferedVideoWaterLevel * m_frameDuration) * bmdAudioSampleRate48kHz) / m_frameTimescale);

	if (m_deckLinkOutput->EnableVideoOutput(displayMode, bmdVideoOutputFlagDefault) != S_OK)
		return false;

	if (m_deckLinkOutput->EnableAudioOutput(bmdAudioSampleRate48kHz, audioSampleType, audioChannelCount, bmdAudioOutputStreamTimestamped) != S_OK)
		return false;

	if (m_deckLinkOutput->SetScreenPreviewCallback(screenPreviewCallback) != S_OK)
		return false;

	return true;
}

void DeckLinkOutputDevice::DisableOutput()
{
	// Dereference DeckLinkOutputDevice delegate from callbacks
	m_deckLinkOutput->SetScheduledFrameCompletionCallback(nullptr);
	m_deckLinkOutput->SetAudioCallback(nullptr);
	m_deckLinkOutput->SetScreenPreviewCallback(nullptr);

	// Disable video and audio outputs
	m_deckLinkOutput->DisableAudioOutput();
	m_deckLinkOutput->DisableVideoOutput();
}

void DeckLinkOutputDevice::SchedulePlaybackThread(CComPtr<SourceReader>& sourceReader)
{
	BOOL isPlaying;

	m_deckLinkOutput->SetScheduledFrameCompletionCallback(this);
	m_deckLinkOutput->SetAudioCallback(this);

	m_endOfStream = false;
	m_prerollingAudio = true;
	m_stopPlayback = false;
	m_deckLinkOutput->BeginAudioPreroll();

	// Start threads to scheduled video and audio capture
	std::thread scheduleVideoFramesThread(&DeckLinkOutputDevice::ScheduleVideoFramesThread, this, sourceReader);
	std::thread scheduleAudioSamplesThread(&DeckLinkOutputDevice::ScheduleAudioSamplesThread, this, sourceReader);

	// Wait for threads to complete
	scheduleVideoFramesThread.join();
	scheduleAudioSamplesThread.join();

	// Stop scheduled output
	if ((m_deckLinkOutput->IsScheduledPlaybackRunning(&isPlaying) == S_OK) && isPlaying)
	{
		// Stop scheduled playback and update start stream time with actual stop time
		m_deckLinkOutput->StopScheduledPlayback(m_scheduledStopTime, &m_scheduledStartTime, m_frameTimescale);
	}
	else
	{
		// Schedule Playback was not already active, most likely that there weren't enough frames in stream to preroll
		// Notify subscriber anyway
		if (m_scheduledPlaybackStoppedCallback != nullptr)
		{
			m_endOfStream = true;
			m_scheduledPlaybackStoppedCallback(m_endOfStream);
		}
	}
}

void DeckLinkOutputDevice::StopScheduledPlayback()
{
	{
		// signal cancel flag to terminate wait condition
		std::lock_guard<std::mutex> lock(m_playbackMutex);
		m_stopPlayback = true;
	}
	m_scheduleVideoFrameCondition.notify_one();
	m_scheduleAudioPacketCondition.notify_one();
}

bool DeckLinkOutputDevice::DisplayPreviewFrame(CComPtr<PlaybackVideoFrame>& videoFrame, bool endOfStream)
{
	CComPtr<IDeckLinkVideoFrame>	outputVideoFrame;

	m_endOfStream = endOfStream;

	if (m_endOfStream)
		return false;

	// Get stream time so we start playback from correct scheduled time
	m_scheduledStartTime = videoFrame->GetStreamTime(m_frameTimescale);

	if (!GetOutputVideoFrame(videoFrame, &outputVideoFrame))
		return false;

	return (m_deckLinkOutput->DisplayVideoFrameSync(outputVideoFrame) == S_OK);
}

void DeckLinkOutputDevice::QueryDisplayModes(std::function<void(CComPtr<IDeckLinkDisplayMode>&)> func)
{
	CComPtr<IDeckLinkDisplayModeIterator>	displayModeIterator;
	CComPtr<IDeckLinkDisplayMode>			displayMode;

	std::lock_guard<std::mutex> lock(m_playbackMutex);

	if (m_deckLinkOutput->GetDisplayModeIterator(&displayModeIterator) != S_OK)
		return;

	while (displayModeIterator->Next(&displayMode) == S_OK)
	{
		func(displayMode);
		displayMode.Release();
	}
}

bool DeckLinkOutputDevice::ScheduleNextVideoFrame(CComPtr<PlaybackVideoFrame>& videoFrame, bool endOfStream)
{
	BMDTimeValue					streamTime;
	CComPtr<IDeckLinkVideoFrame>	outputVideoFrame;

	m_endOfStream = endOfStream;

	if (endOfStream || (videoFrame == nullptr))
		return false;

	streamTime = videoFrame->GetStreamTime(m_frameTimescale);

	if (!GetOutputVideoFrame(videoFrame, &outputVideoFrame))
		return false;

	if (m_deckLinkOutput->ScheduleVideoFrame(outputVideoFrame, streamTime, m_frameDuration, m_frameTimescale) == S_OK)
	{
		// Set scheduled strea time to next stream time
		m_scheduledStopTime = streamTime + m_frameDuration;
		return true;
	}

	return false;
}

bool DeckLinkOutputDevice::ScheduleNextAudioPacket(CComPtr<PlaybackAudioPacket>& audioPacket, bool endOfStream)
{
	void* audioBuffer;

	if (endOfStream || (audioPacket == nullptr))
		return false;

	if (audioPacket->GetBytes(&audioBuffer) != S_OK)
		return false;

	return m_deckLinkOutput->ScheduleAudioSamples(audioBuffer, audioPacket->GetSampleCount(), audioPacket->GetStreamTime(m_frameTimescale), m_frameTimescale, nullptr) == S_OK;
}

void DeckLinkOutputDevice::ScheduleVideoFramesThread(CComPtr<SourceReader>& sourceReader)
{
	bool scheduledPlaybackRunning = true;
	auto scheduleVideoFrameCallback = std::bind(&DeckLinkOutputDevice::ScheduleNextVideoFrame, this, std::placeholders::_1, std::placeholders::_2);

	for (int i = 0; i < (int)m_bufferedVideoWaterLevel; i++)
	{
		if (!sourceReader->ReadVideoFrame(scheduleVideoFrameCallback))
		{
			scheduledPlaybackRunning = false;
			break;
		}
	}

	{
		std::unique_lock<std::mutex> lock(m_playbackMutex);
		m_bufferedVideoFrameCount = m_bufferedVideoWaterLevel;
	}

	while (scheduledPlaybackRunning)
	{
		bool readVideoFrame = false;
		{
			std::unique_lock<std::mutex> lock(m_playbackMutex);
			m_scheduleVideoFrameCondition.wait(lock, [&] { return (m_bufferedVideoFrameCount < m_bufferedVideoWaterLevel) || m_stopPlayback; });

			if (m_stopPlayback)
			{
				// Stop scheduled playback immediately
				m_scheduledStopTime = 0;
				scheduledPlaybackRunning = false;
			}
			else if (m_bufferedVideoFrameCount < m_bufferedVideoWaterLevel)
			{
				readVideoFrame = true;
			}
		}

		if (readVideoFrame)
		{
			if (!sourceReader->ReadVideoFrame(scheduleVideoFrameCallback))
			{
				scheduledPlaybackRunning = false;
			}
		}
	}
}

void DeckLinkOutputDevice::ScheduleAudioSamplesThread(CComPtr<SourceReader>& sourceReader)
{
	bool scheduledPlaybackRunning = true;

	while (scheduledPlaybackRunning)
	{
		bool readAudioPacket = false;
		{
			std::unique_lock<std::mutex> lock(m_playbackMutex);
			m_scheduleAudioPacketCondition.wait(lock, [&]{ return (m_bufferedAudioSampleCount < m_bufferedAudioWaterLevel) || m_stopPlayback; });

			if (m_stopPlayback)
				scheduledPlaybackRunning = false;
			else if (m_bufferedAudioSampleCount < m_bufferedAudioWaterLevel)
				readAudioPacket = true;
		}

		if (readAudioPacket)
		{
			if (!sourceReader->ReadAudioPacket(std::bind(&DeckLinkOutputDevice::ScheduleNextAudioPacket, this, std::placeholders::_1, std::placeholders::_2)))
			{
				scheduledPlaybackRunning = false;
			}
		}
	}
}

bool DeckLinkOutputDevice::GetOutputVideoFrame(CComPtr<PlaybackVideoFrame>& videoFrame, IDeckLinkVideoFrame** outputVideoFrame)
{
	CComPtr<IDeckLinkMutableVideoFrame> newVideoFrame = nullptr;

	if (*outputVideoFrame != nullptr)
		return false;

	if (m_outputWithConversion)
	{
		// Refer to DeckLink SDK Manual - 2.7.4 Pixel Formats
		int outputBytesPerRow = ((videoFrame->GetWidth() + 47) / 48) * 128;;

		if (m_deckLinkOutput->CreateVideoFrame(videoFrame->GetWidth(), videoFrame->GetHeight(), outputBytesPerRow, 
			kConvertedPixelFormat, videoFrame->GetFlags(), &newVideoFrame) != S_OK)
			return false;

		if (m_deckLinkFrameConverter->ConvertFrame((IDeckLinkVideoFrame*)videoFrame, newVideoFrame) != S_OK)
			return false;

		*outputVideoFrame = newVideoFrame.Detach();
	}
	else
		*outputVideoFrame = (IDeckLinkVideoFrame*)videoFrame.Detach();

	return true;
}
