/* -LICENSE-START-
** Copyright (c) 2019 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "stdafx.h"
#include "mfapi.h"
#include <vector>
#include <utility>
#include "FilePlayback.h"
#include "FilePlaybackDlg.h"
#include "SourceReader.h"
#include "windows.h"
#include "About.h"
#include "FileCapture.h"
#include "FileCaptureDlg.h"

// This is fixed (static) values to get 2 channel output
static const uint32_t			kAudioChannelCount = 2;
BMDAudioSampleType	kAudioSampleType = bmdAudioSampleType16bitInteger;

// Declare Filename as null and slider range value
CString							currentFilename = NULL;
static const int				kFilePositionSliderRange = 100;

static CString SecondsToHMS(int64_t seconds)
{
	int64_t hours = seconds / 3600;
	seconds -= (hours * 3600);
	int64_t minutes = seconds / 60;
	seconds -= (minutes * 60);

	CString retString;
	retString.Format(_T("%lld:%02lld:%02lld"), hours, minutes, seconds);
	return retString;
}

CFilePlaybackDlg::CFilePlaybackDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CFilePlaybackDlg::IDD, pParent),
	m_deckLinkDiscovery(nullptr),
	m_selectedDevice(nullptr),
	m_loopCheck(FALSE),
	m_autoplayCheck(FALSE)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

	// Initialize instance variables
	m_playbackState = PlaybackState::OutputDisabled;

	m_selectedDisplayMode = NULL;
	m_selectedVideoOutputFlags = bmdVideoOutputFlagDefault;
}

void CFilePlaybackDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_PLAY_BUTTON, m_playButton);
	DDX_Control(pDX, IDC_OPEN_BUTTON, m_openFileButton);
	DDX_Control(pDX, IDC_DELETE_BUTTON, m_deleteFileButton);
	DDX_Control(pDX, IDC_RESET_BUTTON, m_resetPlaylistButton);
	DDX_Control(pDX, IDC_LOOP, m_loopButton);
	DDX_Control(pDX, IDC_AUTOPLAY_CHECK, m_autoplayButton);
	DDX_Control(pDX, IDC_NEXT_BUTTON, m_nextButton);
	DDX_Control(pDX, IDC_PREV_BUTTON, m_prevButton);
	DDX_Control(pDX, IDC_OUTPUT_DEVICE_COMBO, m_deviceListCombo);
	DDX_Control(pDX, IDC_PLAYLIST, m_playlist);
	DDX_Control(pDX, IDC_VIDEO_FORMAT_EDIT, m_videoFormatEdit);
	DDX_Control(pDX, IDC_AUDIO_CHANNEL, m_audioChannelEdit);
	DDX_Control(pDX, IDC_AUDIO_BIT_DEPTH, m_audioBitDepthEdit);
	DDX_Control(pDX, IDC_FILETITLE_EDIT, m_fileNameEdit);
	DDX_Control(pDX, IDC_POSITION_EDIT, m_filePositionEdit);
	DDX_Control(pDX, IDC_DURATION_EDIT, m_fileDurationEdit);
	DDX_Control(pDX, IDC_POSITION_SLIDER, m_filePositionSlider);
	DDX_Control(pDX, IDC_PREVIEW_BOX, m_previewBox);
	DDX_Control(pDX, IDC_TEST_ABOUT, m_aboutButton);
	DDX_Control(pDX, IDC_FILE_CAPTURE, m_fileCapture);
	DDX_Control(pDX, IDC_STOP_BUTTON, m_stopButton);
	DDX_Control(pDX, IDC_PAUSE_BUTTON, m_pauseButton);
	DDX_Control(pDX, IDC_VIDEO_RES_COMBO, m_videoresCombo);
	DDX_Control(pDX, IDC_AUDIO_DEPTH_COMBO, m_audiodepthCombo);
	DDX_Check(pDX, IDC_LOOP, m_loopCheck);
	DDX_Check(pDX, IDC_AUTOPLAY_CHECK, m_autoplayCheck);
}

BEGIN_MESSAGE_MAP(CFilePlaybackDlg, CDialog)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_PLAY_BUTTON, &CFilePlaybackDlg::OnBnClickedPlay)
	ON_BN_CLICKED(IDC_LOOP, &CFilePlaybackDlg::OnBnClickedLoopCheck)
	ON_BN_CLICKED(IDC_AUTOPLAY_CHECK, &CFilePlaybackDlg::OnBnClickedAutoplayCheck)
	ON_BN_CLICKED(IDC_NEXT_BUTTON, &CFilePlaybackDlg::OnBnClickedNextFile)
	ON_BN_CLICKED(IDC_OPEN_BUTTON, &CFilePlaybackDlg::OnBnClickedOpenFile)
	ON_BN_CLICKED(IDC_DELETE_BUTTON, &CFilePlaybackDlg::OnBnClickedDeleteFile)
	ON_BN_CLICKED(IDC_RESET_BUTTON, &CFilePlaybackDlg::OnBnClickedResetPlaylist)
	ON_LBN_DBLCLK(IDC_PLAYLIST, &CFilePlaybackDlg::OnLbnDblclkPlay)
	ON_CBN_SELCHANGE(IDC_OUTPUT_DEVICE_COMBO, &CFilePlaybackDlg::OnNewDeviceSelected)
	ON_MESSAGE(WM_ADD_DEVICE_MESSAGE, &CFilePlaybackDlg::OnAddDevice)
	ON_MESSAGE(WM_REMOVE_DEVICE_MESSAGE, &CFilePlaybackDlg::OnRemoveDevice)
	ON_MESSAGE(WM_UPDATE_PROFILE_MESSAGE, &CFilePlaybackDlg::OnUpdateProfile)
	ON_MESSAGE(WM_UPDATE_STREAM_TIME_MESSAGE, &CFilePlaybackDlg::OnUpdateStreamTime)
	ON_MESSAGE(WM_OUTPUT_ENABLED_MESSAGE, &CFilePlaybackDlg::OnOutputEnabled)
	ON_MESSAGE(WM_OUTPUT_DISABLED_MESSAGE, &CFilePlaybackDlg::OnOutputDisabled)
	ON_MESSAGE(WM_SCHEDULED_PLAYBACK_STOPPED_MESSAGE, &CFilePlaybackDlg::OnScheduledPlaybackStopped)
	ON_MESSAGE(WM_READ_SAMPLE_ERROR_MESSAGE, &CFilePlaybackDlg::OnReadSampleError)
	ON_MESSAGE(WM_FRAME_DISPLAYED_LATE_MESSAGE, &CFilePlaybackDlg::OnFrameDisplayedLate)
	ON_WM_HSCROLL()
	ON_WM_CLOSE()
	ON_EN_CHANGE(IDC_VIDEO_FORMAT_EDIT, &CFilePlaybackDlg::OnEnChangeVideoFormatEdit)
	ON_BN_CLICKED(IDC_TEST_ABOUT, &CFilePlaybackDlg::OnBnClickedTestAbout)
	ON_EN_CHANGE(IDC_AUDIO_CHANNEL, &CFilePlaybackDlg::OnEnChangeAudioChannel)
	ON_BN_CLICKED(IDC_FILE_CAPTURE, &CFilePlaybackDlg::OnBnClickedFileCapture)
	ON_BN_CLICKED(IDC_PREV_BUTTON, &CFilePlaybackDlg::OnBnClickedPrevButton)
	ON_EN_CHANGE(IDC_AUDIO_BD, &CFilePlaybackDlg::OnEnChangeAudioBd)
	ON_BN_CLICKED(IDC_STOP_BUTTON, &CFilePlaybackDlg::OnBnClickedStopButton)
	ON_BN_CLICKED(IDC_PAUSE_BUTTON, &CFilePlaybackDlg::OnBnClickedPauseButton)
	ON_CBN_SELCHANGE(IDC_VIDEO_RES_COMBO, &CFilePlaybackDlg::OnCbnSelchangeVideoResCombo)
	ON_CBN_SELCHANGE(IDC_AUDIO_DEPTH_COMBO, &CFilePlaybackDlg::OnCbnSelchangeAudioDepthCombo)
END_MESSAGE_MAP()

// CFilePlaybackDlg message handlers
BOOL CFilePlaybackDlg::OnInitDialog()
{
	bool			success = false;
	CDialog::OnInitDialog();

	m_hAccelTable = ::LoadAccelerators(AfxGetResourceHandle(),
		MAKEINTRESOURCE(IDR_ACCELERATOR1));

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	m_filePositionSlider.SetRange(0, kFilePositionSliderRange);
	m_filePositionEdit.SetWindowTextW(SecondsToHMS(0));
	m_fileDurationEdit.SetWindowTextW(SecondsToHMS(0));
	UpdateInterface();
	videoresCombo();
	audiodepthCombo();

	if (MFStartup(MF_VERSION) != S_OK)
	{
		MessageBox(_T("Failed to start Media Foundation."), _T("Error"));
		return -1;
	}

	// Create source reader callback
	m_sourceReader.Attach(new SourceReader());

	// Create and enable DeckLink device discovery callback interface object
	m_deckLinkDiscovery.Attach(new DeckLinkDeviceDiscovery());
	if (m_deckLinkDiscovery != nullptr)
	{
		if (!m_deckLinkDiscovery->Enable())
		{
			MessageBox(_T("This application requires the DeckLink drivers installed.\nPlease install the Blackmagic DeckLink drivers to use the features of this application."), _T("Error"));
			goto bail;
		}

		m_deckLinkDiscovery->OnDeviceArrival([this](CComPtr<IDeckLink>& dl) {
			// Update UI (add new device to menu) from main thread
			PostMessage(WM_ADD_DEVICE_MESSAGE, (WPARAM)dl.Detach(), 0);
			});

		m_deckLinkDiscovery->OnDeviceRemoval([this](CComPtr<IDeckLink>& dl) {
			// Update UI (remove device from menu) from main thread
			PostMessage(WM_REMOVE_DEVICE_MESSAGE, (WPARAM)dl.Detach(), 0);
			dl.Release();
			});
	}

	// Create and initialize preview helper
	m_previewWindow.Attach(new PreviewWindow());
	if (m_previewWindow->Initialize(&m_previewBox) == false)
	{
		MessageBox(_T("This application was unable to initialise the preview window"), _T("Error"));
	}

	// Create profile callback interface object
	m_profileCallback.Attach(new ProfileCallback());
	m_profileCallback->OnHaltStreams(std::bind(&CFilePlaybackDlg::StopScheduledPlayback, this));
	m_profileCallback->OnProfileActivated([this](void) {
		// Update UI with new profile
		PostMessage(WM_UPDATE_PROFILE_MESSAGE, 0, 0);
		});

bail:
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CFilePlaybackDlg::videoresCombo() {
	m_videoresCombo.AddString(_T("1080p 60fps"));
	m_videoresCombo.AddString(_T("1080p 30fps"));
	m_videoresCombo.AddString(_T("720p 60fps"));
	m_videoresCombo.AddString(_T("Same as source"));
}

void CFilePlaybackDlg::audiodepthCombo() {
	m_audiodepthCombo.AddString(_T("16 bit"));
	m_audiodepthCombo.AddString(_T("24 bit"));
	m_audiodepthCombo.AddString(_T("32 bit"));
	m_audiodepthCombo.AddString(_T("Same as source"));
}

void CFilePlaybackDlg::UpdateInterface()
{
	// Set the enable state of user interface elements
	m_deviceListCombo.EnableWindow(m_playbackState != PlaybackState::ScheduledPlayback);
	m_openFileButton.EnableWindow(m_playbackState != PlaybackState::ScheduledPlayback);
	m_playButton.EnableWindow(m_playbackState != PlaybackState::OutputDisabled);
	m_stopButton.EnableWindow(m_playbackState != PlaybackState::OutputDisabled);
	m_pauseButton.EnableWindow(m_playbackState != PlaybackState::OutputDisabled);
	m_filePositionSlider.EnableWindow(m_playbackState == PlaybackState::OutputEnabled);
}

void CFilePlaybackDlg::OnLbcRTclkPlay() {
	m_previewWindow.Attach(new PreviewWindow());
	if (m_previewWindow->Initialize(&m_previewBox) == false)
	{
		MessageBox(_T("This application was unable to initialise the preview window"), _T("Error"));
	}
	UpdateInterface();
	EnableVideoOutput();
}

void CFilePlaybackDlg::OnBnClickedPlay()
{
	CString curname;
	curname = currentFilename;

	if (m_selectedDevice == nullptr)
		return;

	if (m_playbackState == PlaybackState::OutputEnabled)
	{
		if (m_endOfStream)
		{
			// If we have previously reached end of stream, then start from beginning
			m_filePosition = 0;
			m_filePositionSlider.SetPos(0);
			m_filePositionEdit.SetWindowText(SecondsToHMS(m_filePosition / kMFTimescale));
			SeekPosition();
		}
		StartScheduledPlayback();
	}
	else if (m_playbackState == PlaybackState::ScheduledPlayback)
		StopScheduledPlayback();
}

void CFilePlaybackDlg::OnBnClickedStopButton()
{
	DisableVideoOutput();
	m_previewWindow.Release();
	m_filePosition = 0;
	m_filePositionSlider.SetPos(0);
	m_filePositionEdit.SetWindowText(SecondsToHMS(m_filePosition / kMFTimescale));
	SeekPosition();
	m_openFileButton.EnableWindow(1);
	UpdateInterface();
}

void CFilePlaybackDlg::OnBnClickedPauseButton()
{
	if (m_playbackState == PlaybackState::ScheduledPlayback)
		StopScheduledPlayback();

	UpdateInterface();
}

void CFilePlaybackDlg::OnBnClickedNextFile()
{
	// Count currently file on playlist
	CString str;
	int total_playlist = m_playlist.GetCount();
	
	if (total_playlist <= 1)
	{
		str.Format(_T("Total playlist is %d"), total_playlist);
		AfxMessageBox(_T("Can't next playlist !"));
		AfxMessageBox(str);
	}
	else {
		// Count total file with current selected file on the playlist
		// So playlist will stop when reach end of playlist or not selected
		// In the playlist
		int curIndex = 0;
		CString nextPath;
		curIndex = m_playlist.FindStringExact(curIndex, currentFilename);

		if (curIndex + 1 == total_playlist) {
			m_playlist.GetText(0, nextPath);
			AfxMessageBox(_T("End of playlist !"));
			AfxMessageBox(_T("Please select file on the playlist"));
		}
		else {
			m_playlist.GetText((curIndex + 1), nextPath);

			// Check decklink status
			if (m_selectedDevice != nullptr)
			{
					// Stop playback and uninitiliaze it
					m_sourceReader->Uninitialize();
					m_selectedDevice->DisableOutput();
					m_playbackState = PlaybackState::OutputDisabled;
					StopScheduledPlayback();

					// Reset playback duration
					m_filePositionSlider.SetPos(0);
					m_fileDurationEdit.SetWindowTextW(SecondsToHMS(0));
					m_fileNameEdit.SetWindowTextW(0);

					m_sourceReader->Initialize(CString(nextPath));
					m_sourceReader->GetFileDuration(&m_fileDuration);
					m_filePositionSlider.SetPos(0);
					m_fileDurationEdit.SetWindowTextW(SecondsToHMS(m_fileDuration / kMFTimescale));
					m_fileNameEdit.SetWindowTextW(nextPath);

					currentFilename = nextPath;

					EnableVideoOutput();
			}
			else {
				AfxMessageBox(_T("No Connected Decklink"));
			}
		}
	}
}

void CFilePlaybackDlg::OnBnClickedPrevButton()
{
	// Count total file with current selected file on the playlist
	// So playlist will stop when reach end of playlist or not selected
	// In the playlist
	CString str;
	CString prevPath;
	int curIndex = 0;
	curIndex = m_playlist.FindStringExact(curIndex, currentFilename);
	int total_playlist = m_playlist.GetCount();
	if (total_playlist <= 1)
	{
		str.Format(_T("Total playlist is %d"), total_playlist);
		AfxMessageBox(_T("Can't previous playlist !"));
		AfxMessageBox(str);
	}
	else {
		if (curIndex == 0) {
			m_playlist.GetText((curIndex = 0), prevPath);
			AfxMessageBox(_T("End of playlist !"));
			AfxMessageBox(_T("Please select file on the playlist"));
		}
		else {
			m_playlist.GetText((curIndex - 1), prevPath);

			// Check decklink status
			if (m_selectedDevice != nullptr)
			{
				// Stop playback and uninitiliaze it
				m_sourceReader->Uninitialize();
				m_selectedDevice->DisableOutput();
				m_playbackState = PlaybackState::OutputDisabled;
				StopScheduledPlayback();

				// Reset playback duration
				m_filePositionSlider.SetPos(0);
				m_fileDurationEdit.SetWindowTextW(SecondsToHMS(0));
				m_fileNameEdit.SetWindowTextW(0);

				m_sourceReader->Initialize(CString(prevPath));
				m_sourceReader->GetFileDuration(&m_fileDuration);
				m_filePositionSlider.SetPos(0);
				m_fileDurationEdit.SetWindowTextW(SecondsToHMS(m_fileDuration / kMFTimescale));
				m_fileNameEdit.SetWindowTextW(prevPath);

				currentFilename = prevPath;

				EnableVideoOutput();
			}
			else {
				AfxMessageBox(_T("No Connected Decklink"));
			}
		}
	}
}

void CFilePlaybackDlg::OnBnClickedLoopCheck()
{
	UpdateData(TRUE);
	if (m_loopCheck)
	{
		m_autoplayButton.SetCheck(0);
		m_autoplayButton.EnableWindow(0);
	}
	else m_autoplayButton.EnableWindow(1);
}

void CFilePlaybackDlg::OnBnClickedAutoplayCheck()
{
	UpdateData(TRUE);
	if (m_autoplayCheck)
	{
		m_loopButton.SetCheck(0);
		m_loopButton.EnableWindow(0);
	}
	else m_loopButton.EnableWindow(1);
}

void CFilePlaybackDlg::OnBnClickedOpenFile()
{
	CComPtr<IFileOpenDialog>	fileOpen;
	CComPtr<IShellItem>			item;
	PWSTR						pszFilePath = NULL;
	HRESULT						hr;

	const COMDLG_FILTERSPEC filterSpec[] =
	{
		{ L"Movie Files", L"*.mp4;*.mov;" },
		{ L"All files", L"*.*" }
	};

	if (m_selectedDevice && (m_playbackState == PlaybackState::OutputEnabled))
	{
		// Already existing output file, reset source reader and disable output
		m_sourceReader->Uninitialize();

		m_selectedDevice->DisableOutput();
		m_playbackState = PlaybackState::OutputDisabled;
		StopScheduledPlayback();
	}

	// Create the FileOpenDialog object.
	hr = fileOpen.CoCreateInstance(__uuidof(FileOpenDialog), NULL, CLSCTX_INPROC_SERVER);
	if (hr != S_OK)
	{
		goto bail;
	}

	hr = fileOpen->SetFileTypes((sizeof(filterSpec) / sizeof(filterSpec[0])), filterSpec);
	if (hr != S_OK)
	{
		goto bail;
	}

	// Show the Open dialog box.
	hr = fileOpen->Show(NULL);
	if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))
	{
		// The user canceled the dialog. Do not treat as an error.
		hr = S_OK;
		goto bail;
	}
	else if (hr != S_OK)
	{
		goto bail;
	}

	hr = fileOpen->GetResult(&item);
	if (hr != S_OK)
	{
		goto bail;
	}

	hr = item->GetDisplayName(SIGDN_FILESYSPATH, &pszFilePath);
	if (hr != S_OK)
		goto bail;

	currentFilename = pszFilePath;
	if (m_selectedDevice && m_playbackState == PlaybackState::OutputDisabled)
	{
		hr = m_sourceReader->Initialize(CString(pszFilePath));
		if (hr != S_OK)
			goto bail;

		hr = m_sourceReader->GetFileDuration(&m_fileDuration);
		if (hr != S_OK)
			goto bail;

		m_filePositionSlider.SetPos(0);
		m_fileDurationEdit.SetWindowTextW(SecondsToHMS(m_fileDuration / kMFTimescale));
		m_fileNameEdit.SetWindowTextW(pszFilePath);
		EnableVideoOutput();
		UpdateInterface();
	}

	int nIndex = NULL;
	nIndex = m_playlist.FindStringExact(nIndex, pszFilePath);
	if (nIndex == LB_ERR)
	{
		m_playlist.AddString(pszFilePath);
	}

bail:
	if (hr != S_OK)
	{
		MessageBox(_T("Cannot open this file."), _T("Error"));
	}
	CoTaskMemFree(pszFilePath);
}

void CFilePlaybackDlg::OnBnClickedDeleteFile()
{
	int nSel = m_playlist.GetCurSel();
	if (nSel != LB_ERR)
	{
		CString path = NULL;
		m_playlist.GetText(nSel, path);
		CString strMsg;
		strMsg.Format(_T("%s is not %s"), path, currentFilename);

		if (path == currentFilename)
		{
			StopScheduledPlayback();
			m_sourceReader->Uninitialize();
			m_filePositionSlider.SetPos(0);
			m_fileDurationEdit.SetWindowTextW(SecondsToHMS(0));
			m_fileNameEdit.SetWindowTextW(0);
		}
		m_playlist.DeleteString(nSel);
	}
}

void CFilePlaybackDlg::OnLbnDblclkPlay()
{
	int nSel = m_playlist.GetCurSel();
	CString path = NULL;
	m_playlist.GetText(nSel, path);

	if (path != currentFilename)
	{
		m_selectedDevice->StopScheduledPlayback();
		m_sourceReader->Uninitialize();

		m_filePositionSlider.SetPos(0);
		m_fileDurationEdit.SetWindowTextW(SecondsToHMS(0));
		m_fileNameEdit.SetWindowTextW(0);
		m_selectedDevice->DisableOutput();
		m_playbackState = PlaybackState::OutputDisabled;

		m_sourceReader->Initialize(CString(path));
		m_sourceReader->GetFileDuration(&m_fileDuration);
		m_filePositionSlider.SetPos(0);
		m_fileDurationEdit.SetWindowTextW(SecondsToHMS(m_fileDuration / kMFTimescale));
		m_fileNameEdit.SetWindowTextW(path);
		currentFilename = path;
		if ((m_playbackState == PlaybackState::OutputDisabled) && (m_selectedDevice != nullptr))
			EnableVideoOutput();
	}
	else return;
}

void CFilePlaybackDlg::OnBnClickedResetPlaylist()
{
	m_playlist.ResetContent();
	m_filePositionSlider.SetPos(0);
	m_fileDurationEdit.SetWindowTextW(SecondsToHMS(0));
}

void CFilePlaybackDlg::OnNewDeviceSelected()
{
	int		selectedDeviceIndex;

	selectedDeviceIndex = m_deviceListCombo.GetCurSel();
	if (selectedDeviceIndex < 0)
		return;

	// Release profile callback from existing selected device
	if (m_selectedDevice != nullptr)
	{
		if (m_playbackState == PlaybackState::OutputEnabled)
			DisableVideoOutput();

		CComPtr<IDeckLinkProfileManager> profileManager = m_selectedDevice->GetDeviceProfileManager();
		if (profileManager != nullptr)
			profileManager->SetCallback(nullptr);

		m_selectedDevice->OnUpdateStreamTime(nullptr);
		m_selectedDevice->OnOutputStateChanged(nullptr);
		m_selectedDevice->OnScheduledPlaybackStopped(nullptr);
		m_selectedDevice->OnFrameDisplayedLate(nullptr);

		m_selectedDevice.Release();
	}

	m_selectedDevice = (DeckLinkOutputDevice*)m_deviceListCombo.GetItemDataPtr(selectedDeviceIndex);

	// Register profile callback with newly selected device's profile manager
	if (m_selectedDevice != nullptr)
	{
		CComPtr<IDeckLinkProfileManager> profileManager = m_selectedDevice->GetDeviceProfileManager();
		if (profileManager != nullptr)
			profileManager->SetCallback(m_profileCallback);

		m_selectedDevice->OnUpdateStreamTime([this]()
			{
				// Update UI with new profile
				PostMessage(WM_UPDATE_STREAM_TIME_MESSAGE, 0, 0);
			});

		m_selectedDevice->OnOutputStateChanged([this](bool enabled)
			{
				PostMessage(enabled ? WM_OUTPUT_ENABLED_MESSAGE : WM_OUTPUT_DISABLED_MESSAGE, 0, 0);
			});

		m_selectedDevice->OnScheduledPlaybackStopped([this](bool endOfStream)
			{
				m_endOfStream = endOfStream;
				PostMessage(WM_SCHEDULED_PLAYBACK_STOPPED_MESSAGE, 0, 0);
			});

		m_selectedDevice->OnFrameDisplayedLate([this]()
			{
				PostMessage(WM_FRAME_DISPLAYED_LATE_MESSAGE, 0, 0);
			});

		if (m_sourceReader->IsInitialized())
			EnableVideoOutput();
	}
}

void CFilePlaybackDlg::AddDevice(CComPtr<IDeckLink> deckLink)
{
	int								deviceIndex;
	CComPtr<DeckLinkOutputDevice>	newDevice;
	CString							newDeviceName;

	newDevice.Attach(new DeckLinkOutputDevice(deckLink));

	// Initialise new DeckLinkDevice object
	if (!newDevice->Initialize())
	{
		// Device does not have IDeckLinkOutput interface, eg it is a DeckLink Mini Recorder
		return;
	}

	// Add this DeckLink device to the device list
	if (newDevice->GetDeviceName(newDeviceName) != S_OK)
		return;

	deviceIndex = m_deviceListCombo.AddString(newDeviceName);
	if (deviceIndex < 0)
		return;

	m_deviceListCombo.SetItemDataPtr(deviceIndex, (void*)newDevice.Detach());

	if (m_deviceListCombo.GetCount() == 1)
	{
		// We have added our first item, refresh and enable UI
		m_deviceListCombo.SetCurSel(0);
		OnNewDeviceSelected();
	}
}

void CFilePlaybackDlg::RemoveDevice(CComPtr<IDeckLink> deckLink)
{
	int deviceIndex = -1;
	CComPtr<DeckLinkOutputDevice> deviceToRemove = NULL;

	// Find the combo box entry to remove (there may be multiple entries with the same name, but each
	// will have a different data pointer).
	for (deviceIndex = 0; deviceIndex < m_deviceListCombo.GetCount(); ++deviceIndex)
	{
		deviceToRemove = (DeckLinkOutputDevice*)m_deviceListCombo.GetItemDataPtr(deviceIndex);
		if (deviceToRemove->GetDeckLinkInstance() == deckLink)
			break;
	}

	if (deviceToRemove == nullptr)
		return;

	// Remove device from list
	m_deviceListCombo.DeleteString(deviceIndex);

	// If playback is ongoing, stop it
	if ((m_selectedDevice == deviceToRemove) && (m_playbackState == PlaybackState::ScheduledPlayback))
		StopScheduledPlayback();

	// Check how many devices are left
	if (m_deviceListCombo.GetCount() == 0)
	{
		// We have removed the last device, disable the interface.
		m_playbackState = PlaybackState::OutputDisabled;
		UpdateInterface();
		m_selectedDevice = nullptr;
	}
	else if (m_selectedDevice == deviceToRemove)
	{
		// The device that was removed was the one selected in the UI.
		// Select the first available device in the list and reset the UI.
		m_deviceListCombo.SetCurSel(0);
		OnNewDeviceSelected();
	}
}

void	CFilePlaybackDlg::DisableVideoOutput()
{
	if (m_selectedDevice)
	{
		switch (m_playbackState)
		{
		case PlaybackState::ScheduledPlayback:
			m_selectedDevice->StopScheduledPlayback();
			// Deliberate fall-through

		case PlaybackState::OutputEnabled:
			m_selectedDevice->DisableOutput();
			break;

		default:
			break;
		}
	}
}

void	CFilePlaybackDlg::EnableVideoOutput()
{
	if (!m_sourceReader)
		return;

	if (!m_selectedDevice->EnableOutput(LookupDisplayMode(), m_sourceReader->GetVideoPixelFormat(),
		m_sourceReader->GetAudioBitsPerSample(), m_sourceReader->GetAudioChannelCount(),
		m_previewWindow))
	{
		MessageBox(_T("Unable to enable video output with the video mode of the file."), _T("Unable to enable video output"));
		return;
	}

	// Display initial video frame synchronously
	m_sourceReader->ReadVideoFrame(std::bind(&DeckLinkOutputDevice::DisplayPreviewFrame, m_selectedDevice, std::placeholders::_1, std::placeholders::_2));
}


void	CFilePlaybackDlg::StartScheduledPlayback()
{
	// Launch thread to schedule playback
	m_scheduledPlaybackThread = std::thread(&DeckLinkOutputDevice::SchedulePlaybackThread, m_selectedDevice, m_sourceReader);

	// Update the UI
	m_playbackState = PlaybackState::ScheduledPlayback;

	// Disable the user interface while running (prevent the user from making changes to the output signal)
	UpdateInterface();
}


void	CFilePlaybackDlg::StopScheduledPlayback()
{
	if (m_playbackState != PlaybackState::ScheduledPlayback)
		return;

	m_selectedDevice->StopScheduledPlayback();
}

void CFilePlaybackDlg::EndOfStreamSelection(void)
{
}

void	CFilePlaybackDlg::SeekPosition()
{
	// Set source reader position and read next frame, also read audio packet to keep schedule time aligned with video
	m_endOfStream = false;
	m_sourceReader->SetPosition(m_filePosition);
	m_sourceReader->ReadVideoFrame(std::bind(&DeckLinkOutputDevice::DisplayPreviewFrame, m_selectedDevice, std::placeholders::_1, std::placeholders::_2));
	m_sourceReader->ReadAudioPacket(nullptr);
}

BMDDisplayMode CFilePlaybackDlg::LookupDisplayMode(void)
{
	// Declare default output information as not static output
	BMDDisplayMode	bmdDisplayMode = bmdModeUnknown;

	std::vector<CComPtr<IDeckLinkDisplayMode>>	candidateModes;
	float										frameRate = m_sourceReader->GetVideoFrameRate();

	// Create a list of all supported display modes that have a frame rate that is acceptably close to the target frame rate
	m_selectedDevice->QueryDisplayModes([frameRate, &candidateModes](CComPtr<IDeckLinkDisplayMode>& deckLinkDisplayMode)
		{
			BMDTimeValue frameDuration;
			BMDTimeScale timeScale;
			if (deckLinkDisplayMode->GetFrameRate(&frameDuration, &timeScale) != S_OK)
				return;

			auto modeFrameRate = (float)timeScale / (float)frameDuration;
			if ((modeFrameRate - 0.01 < frameRate) && (modeFrameRate + 0.01 > frameRate))
			{
				// For simplicity, assume SD modes are interlaced and HD modes are progressive
				auto fieldDominance = deckLinkDisplayMode->GetFieldDominance();
				if ((deckLinkDisplayMode->GetWidth() > 720 && fieldDominance != bmdProgressiveFrame) ||
					(deckLinkDisplayMode->GetWidth() <= 720 && fieldDominance != bmdLowerFieldFirst && fieldDominance != bmdUpperFieldFirst))
					return;

				candidateModes.push_back(deckLinkDisplayMode);
			}
		});

	// Sort candidate modes in ascending order by frame size
	std::sort(candidateModes.begin(), candidateModes.end(),
		[](CComPtr<IDeckLinkDisplayMode>& t1, CComPtr<IDeckLinkDisplayMode>& t2) {
			return (
				((t1->GetWidth() < t2->GetWidth()) && (t1->GetHeight() <= t2->GetHeight())) ||
				((t1->GetHeight() < t2->GetHeight()) && (t1->GetWidth() <= t2->GetWidth()))
				);
		});

	// Try to find the best fit (first mode where frame size >= target frame size)
	for (auto candidateMode : candidateModes)
	{
		if (candidateMode->GetWidth() >= m_sourceReader->GetVideoFrameWidth() &&
			candidateMode->GetHeight() >= m_sourceReader->GetVideoFrameHeight())
		{
			CString videores;
			CString audiodepth;
			int index = m_videoresCombo.GetCurSel();
			int audiodepthCombo2 = m_audiodepthCombo.GetCurSel();

			if (index != CB_ERR)
			{
				this->m_videoresCombo.GetLBText(index, videores);

				if (videores == _T("1080p 60fps")) {
					bmdDisplayMode = bmdModeHD1080p5994;
				}
				else if (videores == _T("1080p 30fps")) {
					bmdDisplayMode = bmdModeHD1080p30;
				}
				else if (videores == _T("720p 60fps")) {
					bmdDisplayMode = bmdModeHD720p60;
				}
				else if (videores == _T("Same as source")) {
					bmdDisplayMode = candidateMode->GetDisplayMode();
					break;
				}
			}
			else {
				bmdDisplayMode = candidateMode->GetDisplayMode();
				break;
			}

			if (audiodepthCombo2 != CB_ERR)
			{
				this->m_audiodepthCombo.GetLBText(audiodepthCombo2, audiodepth);

				if (audiodepth == _T("16 bit")) {
					kAudioSampleType = bmdAudioSampleType16bitInteger;
				}
				else if (audiodepth == _T("24 bit")) {
					kAudioSampleType = bmdAudioSampleType24bitInteger;
				}
				else if (audiodepth == _T("32 bit")) {
					kAudioSampleType = bmdAudioSampleType32bitInteger;
				}
				else if (audiodepth == _T("Same as source")) {
					kAudioSampleType = bmdAudioSampleType16bitInteger;
				}
			}
			else {
				kAudioSampleType = bmdAudioSampleType16bitInteger;
				break;
			}
		}
	}
	return bmdDisplayMode;
}

LRESULT CFilePlaybackDlg::OnAddDevice(WPARAM wParam, LPARAM lParam)
{
	// A new device has been connected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	AddDevice(deckLink);
	return 0;
}

LRESULT	CFilePlaybackDlg::OnRemoveDevice(WPARAM wParam, LPARAM lParam)
{
	// An existing device has been disconnected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	RemoveDevice(deckLink);
	return 0;
}

LRESULT CFilePlaybackDlg::OnUpdateProfile(WPARAM wParam, LPARAM lParam)
{
	return LRESULT();
}

LRESULT CFilePlaybackDlg::OnUpdateStreamTime(WPARAM wParam, LPARAM lParam)
{
	// Get stream time in media foundation timescale
	BMDTimeValue streamTime = m_selectedDevice->GetCurrentStreamTime(kMFTimescale);

	m_filePositionEdit.SetWindowTextW(SecondsToHMS(streamTime / kMFTimescale));
	m_filePositionSlider.SetPos((int)((int64_t)kFilePositionSliderRange * streamTime / m_fileDuration));

	return 0;
}

LRESULT CFilePlaybackDlg::OnOutputEnabled(WPARAM wParam, LPARAM lParam)
{
	// Show Declink Output Information
	CString displayModeName; // Show Full Video Codec Information
	CString displayAudioChannel; // Show Audio Channel Information
	CString displayAudioBitDepth; // Show Audio Bit Depth Information

	// Make sure if user already selected decklink before playback
	if (m_selectedDevice != nullptr)
	{
		// Get value for audio channel & bit depth
		displayAudioChannel.Format(_T("%d"), kAudioChannelCount);
		displayAudioBitDepth.Format(_T("%d"), kAudioSampleType);

		if (m_selectedDevice->GetDisplayModeName(displayModeName) == S_OK) {
			m_videoFormatEdit.SetWindowText(displayModeName);
			m_audioChannelEdit.SetWindowText(displayAudioChannel);
			m_audioBitDepthEdit.SetWindowText(displayAudioBitDepth);
		}

		m_playbackState = PlaybackState::OutputEnabled;
		UpdateInterface();

		return 0;
	}
	else {
		MessageBox(_T("No Decklink Device Selected."), _T("Error"));

		// Disable Video Output if no decklink device selected
		m_videoFormatEdit.SetWindowText(_T(""));
		m_audioChannelEdit.SetWindowText(_T(""));
		m_audioBitDepthEdit.SetWindowText(_T(""));

		m_playbackState = PlaybackState::OutputDisabled;
		UpdateInterface();

		return 0;
	}
}

LRESULT CFilePlaybackDlg::OnOutputDisabled(WPARAM wParam, LPARAM lParam)
{
	// Cleanup initialization after output disabled
	m_videoFormatEdit.SetWindowText(_T(""));
	m_audioChannelEdit.SetWindowText(_T(""));
	m_audioBitDepthEdit.SetWindowText(_T(""));

	m_playbackState = PlaybackState::OutputDisabled;
	UpdateInterface();

	return 0;
}

LRESULT CFilePlaybackDlg::OnScheduledPlaybackStopped(WPARAM wParam, LPARAM lParam)
{
	// Wait until schduled playback thread completes
	m_scheduledPlaybackThread.join();

	if (m_playbackState == PlaybackState::ScheduledPlayback)
		m_playbackState = PlaybackState::OutputEnabled;
	UpdateInterface();

	return 0;
}

LRESULT CFilePlaybackDlg::OnReadSampleError(WPARAM wParam, LPARAM lParam)
{
	return 0;
}

LRESULT CFilePlaybackDlg::OnFrameDisplayedLate(WPARAM wParam, LPARAM lParam)
{
	MessageBox(_T("The system may not be fast enough to play this file."), _T("Frame Displayed Late"));
	OnOutputDisabled(0, 0);
	return 0;
}

void CFilePlaybackDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	CSliderCtrl* slider = reinterpret_cast<CSliderCtrl*>(pScrollBar);

	if ((slider->GetDlgCtrlID() == IDC_POSITION_SLIDER) && (m_playbackState == PlaybackState::OutputEnabled))
	{
		m_filePosition = slider->GetPos() * m_fileDuration / kFilePositionSliderRange;
		m_filePositionEdit.SetWindowText(SecondsToHMS(m_filePosition / kMFTimescale));
		SeekPosition();
	}

	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CFilePlaybackDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

void CFilePlaybackDlg::OnClose()
{
	// Disable profile callback
	if (m_selectedDevice != nullptr)
	{
		DisableVideoOutput();

		if (m_selectedDevice->GetDeviceProfileManager() != nullptr)
		{
			m_selectedDevice->GetDeviceProfileManager()->SetCallback(nullptr);
		}
		m_selectedDevice.Release();
	}

	// Release profile callback
	m_profileCallback.Release();

	// Release all DeckLinkOutputDevice instances
	for (int i = 0; i < m_deviceListCombo.GetCount(); i++)
	{
		CComPtr<DeckLinkOutputDevice> device;
		device.Attach((DeckLinkOutputDevice*)m_deviceListCombo.GetItemDataPtr(i));
		(void)device->Uninitialize();
		device.Release();
	}

	// Disable and release DeckLink device discovery
	m_deckLinkDiscovery->Disable();
	m_deckLinkDiscovery.Release();

	// Release preview window
	m_previewWindow.Release();

	// Release MF Source Reader
	m_sourceReader->Uninitialize();
	m_sourceReader.Release();

	// Shutdown Media Foundation
	MFShutdown();

	CDialog::OnClose();
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CFilePlaybackDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void CFilePlaybackDlg::OnEnChangeVideoFormatEdit()
{
	// TODO:  If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	// TODO:  Add your control notification handler code here
}

void CFilePlaybackDlg::OnEnChangeAudioChannel()
{
	// TODO:  If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	// TODO:  Add your control notification handler code here
}


void CFilePlaybackDlg::OnEnChangeAudioBd()
{
	// TODO:  If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	// TODO:  Add your control notification handler code here
}

BOOL CFilePlaybackDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	if (WM_KEYFIRST <= pMsg->message && pMsg->message
		<= WM_KEYLAST)
		if (m_hAccelTable && ::TranslateAccelerator
		(m_hWnd, m_hAccelTable, pMsg))
			return TRUE;

	return CDialog::PreTranslateMessage(pMsg);
}

void CFilePlaybackDlg::LoopCheck()
{
	// TODO: Add your implementation code here.
	//OnBnClickedPlay();
	//m_endOfStream = false;
	//AfxMessageBox(_T("Worked!"));
	//m_filePosition = 0;
	//m_filePositionEdit.SetWindowText(SecondsToHMS(m_filePosition / kMFTimescale));
	//SeekPosition();
	Sleep(2000);
	OnBnClickedPlay();
}

void CFilePlaybackDlg::AutoplayCheck()
{
	// TODO: Add your implementation code here.
	OnBnClickedNextFile();
}

void CFilePlaybackDlg::OnBnClickedTestAbout()
{
	About dlg;
	dlg.DoModal();
}

void CFilePlaybackDlg::OnBnClickedFileCapture()
{
	CFileCaptureDlg dlg;
	dlg.DoModal();
}

void CFilePlaybackDlg::OnCbnSelchangeVideoResCombo()
{
	BMDDisplayMode	bmdDisplayMode = bmdModeUnknown;
	std::vector<CComPtr<IDeckLinkDisplayMode>>	candidateModes;
	float	frameRate = m_sourceReader->GetVideoFrameRate();

	if (m_playbackState == PlaybackState::OutputEnabled) {
		CString videores;
			int index = m_videoresCombo.GetCurSel();
			if (index != CB_ERR)
			{
				this->m_videoresCombo.GetLBText(index, videores);

					if (videores == _T("1080p 60fps")) {
						bmdDisplayMode = bmdModeHD1080p5994;
					}
					else if (videores == _T("1080p 30fps")) {
						bmdDisplayMode = bmdModeHD1080p30;
					}
					else if (videores == _T("720p 60fps")) {
						bmdDisplayMode = bmdModeHD720p60;
					}
					else if (videores == _T("Same as source")) {
						DisableVideoOutput();
						EnableVideoOutput();
					}
			}
		DisableVideoOutput();
		EnableVideoOutput();
	}
}

void CFilePlaybackDlg::OnCbnSelchangeAudioDepthCombo()
{
	BMDAudioSampleType	kAudioSampleType = bmdAudioSampleType16bitInteger;
	CString audiodepth;
	int audiodepthCombo2 = m_audiodepthCombo.GetCurSel();

	if (m_playbackState == PlaybackState::OutputEnabled) {
		if (audiodepthCombo2 != CB_ERR)
		{
			this->m_audiodepthCombo.GetLBText(audiodepthCombo2, audiodepth);

			if (audiodepth == _T("16 bit")) {
				kAudioSampleType = bmdAudioSampleType16bitInteger;
			}
			else if (audiodepth == _T("24 bit")) {
				kAudioSampleType = bmdAudioSampleType24bitInteger;
			}
			else if (audiodepth == _T("32 bit")) {
				kAudioSampleType = bmdAudioSampleType32bitInteger;
			}
			else if (audiodepth == _T("Same as source")) {
				kAudioSampleType = bmdAudioSampleType16bitInteger;
			}
		}
		else {
			kAudioSampleType = bmdAudioSampleType16bitInteger;
		}
		DisableVideoOutput();
		EnableVideoOutput();
	}
}